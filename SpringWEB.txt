+++++++++++++++Http протокол:++++++++++++++


1. Расскажите, чем отличается UDP от TCP/IP.
	TCP — надёжный, но медленнее(передача файлов, веб-страницы). UDP — быстрый, но без гарантий доставки(стриминг, онлайн-игры).

2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.
	это протокол прикладного уровня, используемый для передачи данных в вебе. 
	Он определяет набор методов (HTTP-методов или HTTP-глаголов), которые указывают, какое действие нужно выполнить с ресурсом.
	Основные методы HTTP:
	GET — получение данных.
	POST — создание данных.
	PUT — полное обновление данных.
	DELETE — удаление данных.
	
3. Расскажите о статусах HTTP протокола.
	Стартовая строка запроса включает в себя:
		Название HTTP-метода, указывающее на действие, которое должен выполнить сервер. Чаще всего используются методы GET (запрос на получение веб - страницы) и POST(передача данных на сервер). 
		Путь к ресурсу 
		Версию HTTP-протокола. 
	
	Cтартовая строка HTTP-ответа имеет немного другую структуру, она состоит из следующих элементов: 
	Версия протокола, обычно HTTP/1.1. 
	Код состояния, показывающий, был ли запрос успешным. 
	Пояснение - краткое текстовое описание кода состояния. 
	
	Коды состояния HTTP представляют собой трехзначные числа от 100 до 510. Они делятся на следующие группы: 
		Информационные (100-105). 
		Успешное выполнение (200-226). 
		Перенаправление (300-307). 
		Ошибка клиента (400-499). 
		Ошибка сервера (500-510).   
		
4. Расскажите о mime-type HTTP протокола.
	Internet Media Types[1], также известные как MIME-типы[2] (Multipurpose Internet Mail Extensions), 
	представляют собой стандарты для обозначения типов данных, которые могут быть переданы посредством 
	сети Интернет с применением стандарта MIME. MIME-типы используются для указания формата данных, отправляемых и получаемых в электронной почте,
	веб-браузерах и других интернет-приложениях.

	Каждый MIME-тип состоит из двух частей: основной тип и подтип, разделенные слешем. Например, `text/plain` указывает на простой текстовый файл, 
	где `text` — это основной тип, а `plain` — подтип.
	
	MIME-типы играют ключевую роль в различных интернет-протоколах, таких как HTTP, SMTP и SIP, обеспечивая интероперабельность и совместимость
	 между различными системами и приложениями. MIME-типы также используются для кодирования бинарных данных в текстовый формат, что особенно важно 
	 для передачи данных в электронной почте и других текстовых протоколах.
	 
	 
++++++++++++++++++++++Веб-контейнер:++++++++++++++++++++++++


1. Что такое сервлет?
	Сервлет Java — это Java-класс, который обрабатывает HTTP-запросы и формирует HTTP-ответы, работая на стороне сервера. Сервлеты являются ключевым компонентом веб-приложений на платформе 
	Java EE (Jakarta EE или SpringWEB) и используются для создания динамического содержимого.

2. Какова структура веб-проекта?
	my-web-app/
	├── src/
	│   ├── main/
	│   │   ├── java/            # Исходные Java-классы (сервлеты, DAO, сервисы)
	│   │   │   └── com/
	│   │   │       └── example/
	│   │   │           ├── servlets/
	│   │   │           │   └── MyServlet.java
	│   │   │           └── config/
	│   │   │               └── AppConfig.java
	│   │   ├── resources/       # Ресурсы (properties, XML, SQL-скрипты)
	│   │   │   ├── config.properties
	│   │   │   └── log4j2.xml
	│   │   └── webapp/          # Веб-контент (JSP, HTML, CSS, JS)
	│   │       ├── WEB-INF/
	│   │       │   ├── web.xml  # Дескриптор развёртывания (опционально с аннотациями)
	│   │       │   └── classes/ # Скомпилированные классы (автогенерация)
	│   │       ├── index.jsp
	│   │       ├── css/
	│   │       │   └── style.css
	│   │       └── js/
	│   │           └── script.js
	│   └── test/                # Тесты (JUnit, TestNG)
	│       ├── java/
	│       └── resources/
	├── target/                  # Сгенерированные артефакты (WAR-файл)
	│   └── my-web-app.war
	├── pom.xml                  # Maven-конфигурация
	└── README.md

	В стандартной структуре Jakarta EE (Servlet-based) проектов (как в предыдущем ответе) действительно нет папок controller, service, repository и т. д., 
	потому что это не часть официального стандарта, а архитектурный паттерн, который стал популярен благодаря фреймворкам (Spring, Micronaut, Quarkus).
	src/
	├── main/
	│   ├── java/
	│   │   └── com/
	│   │       └── example/
	│   │           ├── config/       # Конфигурационные классы (@Configuration)
	│   │           ├── controller/  # Контроллеры (@RestController, @Controller)
	│   │           ├── dto/         # Data Transfer Objects (JSON-модели)
	│   │           ├── exception/   # Обработчики ошибок (@ControllerAdvice)
	│   │           ├── filter/      # Фильтры (@WebFilter или OncePerRequestFilter)
	│   │           ├── model/       # Сущности БД (@Entity)
	│   │           ├── repository/  # Репозитории (JPA, CrudRepository)
	│   │           ├── service/     # Бизнес-логика (@Service)
	│   │           └── Application.java  # Главный класс (@SpringBootApplication)
	│   └── resources/
	│       ├── static/    # CSS, JS, изображения
	│       ├── templates/ # HTML (Thymeleaf, Freemarker)
	│       ├── application.properties  # Настройки
	│       └── data.sql   # Инициализация БД (опционально)
	├── test/              # Тесты
	└── pom.xml

3. Что такое контейнер сервлетов?
	Контейнер сервлетов — это программа (или часть сервера приложений), которая управляет жизненным циклом сервлетов, обрабатывает HTTP-запросы и формирует ответы. 
	Это среда, в которой выполняются Java-сервлеты и JSP-страницы.
	Управление жизненным циклом сервлетов:
		-Создает экземпляры сервлетов (init()).
		-Вызывает методы (service(), doGet(), doPost()) для обработки запросов.
		-Уничтожает сервлеты (destroy()), когда они больше не нужны.
	Обработка HTTP-запросов
		-Принимает запросы от клиента (браузера, мобильного приложения).
		-Преобразует их в объекты HttpServletRequest.
		-Передает управление соответствующему сервлету.
	Формирование HTTP-ответов
		-Преобразует HttpServletResponse в HTTP-ответ (HTML, JSON и т. д.).
		-Отправляет ответ клиенту.
	Поддержка сессий (Session Management)
		-Создает и управляет HttpSession (хранение данных между запросами).
	Фильтрация запросов (Servlet Filters)
		-Позволяет добавлять пред- и пост-обработку запросов (например, аутентификацию, логирование).
	Пул потоков (Thread Pooling)
		-Обрабатывает несколько запросов одновременно, используя многопоточность.
		
	Примеры контейнеров сервлетов
	Apache Tomcat (наиболее популярный, легковесный, только сервлеты/JSP), Jetty (встраиваемый, используется в Spring Boot), Undertow (высокопроизводительный, поддерживает HTTP/2),
	WildFly (бывший JBoss), Payara (развитие GlassFish), WebLogic (Oracle).
	
4. Каковы задачи, функциональность контейнера сервлетов?
	При запуске веб-приложения на сервере, сначала разворачивается контейнер сервлетов, и в него загружаются сервлеты. Далее при обращении клиента к серверу,
	запрос обрабатывается контейнером и выбирается сервлет, который будет этот запрос обрабатывать, после чего ему передаётся этот запрос.
		Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, например Apache,
	или интегрироваться в Java EE сервер приложений. Контейнер сервлетов обеспечивает обмен данными между клиентами и сервлетом и берёт на себя выполнение таких функций, 
	как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них. 
		Также помимо приема запросов и передачи ответов, контейнер сервлетов выполняет и другие задачи, например, шифрует и дешифрует HTTPS-сообщения или производит 
	динамическую генерацию HTML-страниц из JSP-файлов.
	
5. Что вы знаете о сервлет фильтрах?
		Сервлет-фильтр - по спецификации это Java-код, который пригоден для повторного использования и позволяет преобразовать содержание HTTP-запросов и ответов,
	а также информацию, которую содержат HTTP-заголовки. Сервлет-фильтр занимается предварительной обработкой запроса перед тем, как запрос попадает в сервлет, 
	и/или последующей обработкой ответа, который исходит из сервлета.

	Возможности сервлет-фильтров:
	- перехватить инициализацию сервлета и определить содержание запроса до того, как сервлет будет инициирован.
	- модифицировать заголовки и данные запроса, в которые упаковывается входящий запрос.
	- модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ.
	- перехватывать инициализацию сервлета до обращения к нему.  

	Сервлет-фильтр может быть сконфигурирован таким образом, чтобы он работал с одним сервлетом или их группой.
	В основе формирования сервлет-фильтров лежит интерфейс javax.servlet.Filter, реализующий три метода:
		- void init (FilterConfig config) 
		- void destroy()
		- void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) 
	Перед тем, как фильтр начнёт свою работу, происходит вызов метода init(), производящий настройку конфигурационного объекта фильтра. 
	Далее в методе doFilter() происходит работа самого фильтра. Сервер вызывает метод init() лишь единожды, чтобы запустить фильтр, после чего метод doFilter() вызывается столько раз, 
	сколько запросов будет сделано к данному фильтру. Метод destroy() вызывается после окончания работы фильтра.

6. Зачем нужны слушатели в сервлетах?
	Cлушатель - это триггер, выполняющий определённые действия при наступлении какого-либо события в жизненном цикле сервлета. То есть это классы, которые отслеживают некоторые события в работе сервлета.
	Слушатели различаются по области видимости: 
	- Request (слушатель запроса):  ServletRequestListener применяется для поимки момента создания и уничтожения запроса. 
		ServletRequestAttributeListener применяется для прослушивания событий, происходящих с атрибутами запроса.
	- Context (слушатель контекста):  ServletContextListener ловит момент инициализации или уничтожения контекста. ServletContextAttributeListener используется для прослушивания событий, 
		происходящих с атрибутами в контексте.
	- Session (слушатель сессии): 
		- HttpSessionListener ловит момент создания и уничтожения сессии. 
		- HttpSessionActivationListener применяется в случае, когда происходит миграция сессии между различными JVM в распределённых приложениях.
		- HttpSessionAttributeListener прослушивает события, происходящие с атрибутами в сессии.
		- HttpSessionBindingListener также используется для прослушивания событий, происходящих с атрибутами в сессии, но со следующими отличиями: HttpSessionAttributeListener 
		декларируется в дескрипторе web.xml, экземпляр класса создается контейнером автоматически в единственном числе и применяется ко всем сессиям, а для HttpSessionBindingListener 
		экземпляр класса должен быть создан и закреплён за определённой сессией «вручную», количество экземпляров также регулируется самостоятельно.

7. Когда вы будете использовать фильтры, а когда слушатели?
	Если нужно обрабатывать входящие или исходящие данные (например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), то необходимо использовать фильтры. 
	А в случаях, когда нужно реагировать на события, лучше применять слушателей.
	
8. Как обработать исключения, выброшенные другим сервлетом в приложении?
	Когда в приложении происходит выброс исключения, контейнер сервлетов его обрабатывает и создаёт ответ в формате HTML. Контейнер сервлетов создаёт HTTP-ответ,
	т.к. браузер понимает только HTTP. Это аналогично тому, что происходит при кодах ошибок типа 403, 404 и т.д. Также существует возможность написания собственных 
	сервлетов для обработки исключений и ошибок с указанием их в дескрипторе развертывания. Цель таких сервлетов - обработка ошибки или исключения и формирования 
	понятного HTTP-ответа пользователю. Например, описать какие-то детали об ошибке или предоставить ссылку на другую страницу.
	
9. Что такое дескриптор развертывания?
	Обычно контейнер сервлетов загружает сервлет не при старте приложения, а по первому запросу клиента. При необходимости загрузить сервлет сразу, например, 
	если сервлет загружается достаточно долго, то следует использовать элемент <load-on-startup> в дескрипторе развертывания или аннотацию @loadOnStartup в коде
	сервлета, это будет указывать, что сервлет необходимо загружать при запуске.  Значение задаётся в виде int. Если значение отрицательное, то сервлет будет загружен при 
	первом запросе клиента. Если неотрицательное (0 и больше), то при старте приложения. Чем меньше число, тем раньше будет стоять сервлет в очереди на загрузку.
	
11. Что представляет собой объект ServletConfig?
	Интерфейс javax.servlet.ServletConfig применяется для передачи сервлету информации о конфигурации. Все сервлеты имеют собственный экземпляр объекта ServletConfig,
	 который создаёт контейнер сервлетов.  Установка параметров конфигурации делается с помощью параметров init-param в дескрипторе web.xml:
	<servlet>
		<servlet-name>ExampleServlet</servlet-name>
		<servlet-class>examplecompany.ExampleServlet</servlet-class>
		<init-param>
			<param-name>parameter</param-name>
			<param-value>parameterValue</param-value>
		</init-param>
	</servlet>
	Получить ServletConfig сервлета можно с помощью метода getServletConfig().
	
12. Что представляет собой объект ServletContext?
	ServletContext - это уникальный объект в веб-приложении. Он реализует интерфейс javax.servlet.ServletContext и предоставляет доступ сервлетам к параметрам веб-приложения. 
	Для предоставления доступа применяется элемент <context-param> в web.xml:
	<web-app>
		...пропущено...
		<context-param>
			<param-name>exampleParameter</param-name>
			<param-value>parameterValue</param-value>
		</context-param>
		...пропущено...
	</web-app>
	Получить ServletContext можно с помощью метода getServletContext() у интерфейса ServletConfig. Контейнеры сервлетов тоже могут предоставлять контекстные объекты, 
	уникальные для группы сервлетов. Каждая из таких групп будет связана со своим набором URL-путей хоста. ServletContext был расширен в спецификации Servlet 3 и теперь имеется 
	возможность программного добавления слушателей и фильтров в приложение. Основные полезные методы этого интерфейса: getServerInfo(), getResourceAsStream(), getMimeType().
	
13. В чем отличия ServletContext и ServletConfig?
	- ServletContext - уникальный для приложения. ServletConfig - уникальный для сервлета.
	- ServletContext используется для предоставления параметров инициализации для всех сервлетов в приложении, а ServletConfig - только определённому сервлету.
	- в объекте ServletContext можно изменять атрибуты, в ServletConfig нет.

14. Что такое Request Dispatcher?
	RequestDispatcher - это интерфейс, который используется для передачи запроса другому ресурсу, при этом можно добавить данные, полученные из этого ресурса, 
	к собственному ответу сервлета. Также RequestDispatcher применяется для внутренней коммуникации между сервлетами в одном контексте. 
	В RequestDispatcher реализовано два метода: 
	- void forward(ServletRequest var1, ServletResponse var2) - этот метод передает запрос из сервлета другому ресурсу на сервере. Например, сервлету, HTML-файлу или JSP.
	- void include(ServletRequest var1, ServletResponse var2) - этот метод включает контент ресурса в ответ. Например, сервлет, HTML-страница или JSP. 
	- getRequestDispatcher(String path) - с помощью этого метода класса ServletContext можно получить доступ к интерфейсу RequestDispatcher.  


+++++++++++++++++++++++++Thymeleaf:++++++++++++++++++++++++++

1. Расскажите о назначении Thymeleaf?
	Thymeleaf — это современный шаблонизатор для Java-приложений, предназначенный для генерации HTML, XML, JavaScript, CSS и других текстовых форматов на стороне сервера.
	
2. Расскажите про тег th:text.
	th:text — Он позволяет динамически вставлять текст в HTML-элемент, заменяя его статическое содержимое на значение, 
	переданное из Java-кода (например, из модели Spring MVC).
	Основные возможности th:text:
		1. Подстановка значений из модели  <p th:text="${message}">Текст по умолчанию</p>
		2. Экранирование HTML (защита от XSS) Thymeleaf автоматически экранирует спецсимволы (<, >, & и др.), предотвращая XSS-атаки.
		3. Работа с переменными и выражениями
			<div th:with="name='Алексей'">
			<p th:text="'Привет, ' + ${name} + '!'"></p>
			</div>
3. Расскажите про тег th:if.
	th:if — это условный атрибут в Thymeleaf, который отображает HTML-элемент только при выполнении указанного условия. Если условие ложно (false), 
	элемент полностью удаляется из DOM (не просто скрывается, а отсутствует в итоговом HTML).
	Основные возможности th:if:
	1. Проверка условий
		<div th:if="${user != null}">
		<p>Привет, <span th:text="${user.name}"></span>!</p>
		</div>
	2. Логические операции
		Поддерживает: && (AND), || (OR), ! (NOT).
	3. Проверка на пустоту #strings.isEmpty(text) — для строк. #lists.isEmpty(collection) — для коллекций
	4. Сравнение значений ==, !=, >, <, и т.д.
		<span th:if="${user.age >= 18}">Взрослый</span>
		<span th:if="${user.age < 18}">Ребёнок</span>

4. Расскажите про тег th:href.
	th:href — это атрибут Thymeleaf, который динамически формирует URL-адреса в HTML-ссылках (<a>),
	стилях (<link>) или скриптах (<script>). Он позволяет создавать гибкие ссылки, учитывающие контекст приложения, параметры и переменные из модели.
	Основные возможности th:href:
	1. Динамические ссылки на URL <a th:href="@{/products}">Список товаров</a>               Результат: http://example.com/app/products).
	2. Передача параметров <a th:href="@{/products(id=${productId}, page=1)}">Товар #42</a>  Результат: /products?id=42&page=1.
	3. Относительные и абсолютные пути
		-Относительный путь (от корня приложения):<a th:href="@{~/images/logo.png}">Логотип</a>
		-Абсолютный URL:<a th:href="@{https://example.com/api}">Внешний API</a>
	4. Работа с переменными модели <a th:href="@{/user/${userId}/profile}">Профиль</a> 		Если userId = 123, сгенерируется: /user/123/profile.
	5. Ссылки с якорями (#) <a th:href="@{/faq#section-2}">Раздел 2</a>
	
5. Расскажите про тег th:each.
	th:each — это атрибут Thymeleaf, предназначенный для перебора коллекций (списков, массивов, множеств, Map)
	и генерации HTML-элементов для каждого элемента коллекции. Это аналог цикла for в Java, но работающий прямо в HTML-шаблоне.
	Основные возможности th:each:
	Базовая форма записи
		<ul>
		<li th:each="item : ${items}" th:text="${item}"></li>
		</ul>
	Перебор Map (словарей)
		<ul>
		<li th:each="entry : ${map}" 
			th:text="${entry.key} + ': ' + ${entry.value}">
		</li>
		</ul>
		
6. Расскажите про тег th:object.
	Тег th:object в Thymeleaf используется для указания объекта модели, к свойствам которого будут обращаться другие 
	Thymeleaf-выражения внутри блока этого тега. Это позволяет упростить синтаксис и сделать код более читаемым.
	Основные особенности:
	-Указывает объект для текущего контекста: th:object задает объект, который будет использоваться по умолчанию для выражений внутри его области видимости.
	-Синтаксис с звездочкой (*): Внутри блока th:object можно использовать сокращенный синтаксис ${*{property}} вместо полного ${object.property}.
	-Область действия: Действует только внутри элемента, к которому применен, и его дочерних элементов.
	
7. Расскажите про тег th:action.
	Тег th:action используется для динамического указания URL-адреса, на который будет отправлена форма при ее submission. 
	Это аналог HTML-атрибута action, но с возможностью использования выражений Thymeleaf.
	<form th:action="@{/submit-url}">...</form>
	

+++++++++++++++++++++++++++++Spring boot:+++++++++++++++++++++++++++++++


1. Опишите из каких компонентов состоит Spring boot?
Spring Boot состоит из нескольких ключевых компонентов, которые работают вместе для упрощения разработки Spring-приложений. Вот основные из них:
	1. Spring Boot Starter
	Назначение: Упрощение управления зависимостями
	Примеры:
	spring-boot-starter-web (для веб-приложений)
	spring-boot-starter-data-jpa (для работы с JPA)
	spring-boot-starter-test (для тестирования)
	
	2. Spring Boot Autoconfigure
	Назначение: Автоматическая конфигурация приложения на основе:
	Доступных классов в classpath
	Определенных бинов
	Настроек properties/yaml
	
	3. Spring Boot CLI
	Назначение: Инструмент командной строки для быстрой разработки:
	Запуск приложений
	Генерация кода
	Выполнение Groovy-скриптов

	4. Встроенные серверы
	Поддержка:
	Tomcat (по умолчанию)
	Jetty
	Undertow

	5. Spring Boot Annotations
	Ключевые аннотации:
	@SpringBootApplication
	@EnableAutoConfiguration
	@ConfigurationProperties

	6. Конфигурация
	Форматы:
	application.properties
	application.yml
	Профили конфигурации

	10. Spring Boot Testing
	Поддержка:
	@SpringBootTest

2. Что такое контроллер и как он связан с DispatcherServlet.
	Контроллер в Spring MVC — это компонент, который обрабатывает HTTP-запросы и возвращает ответы. Это центральный элемент в архитектуре 
	MVC (Model-View-Controller), отвечающий за:
	-Прием входящих запросов от клиентов
	-Обработку бизнес-логики (часто делегируя сервисам)
	-Подготовку модели данных
	-Возврат соответствующего представления или данных
	Связь с DispatcherServlet
	
	DispatcherServlet — это центральный диспетчер (фронт-контроллер) в Spring MVC, 
	который координирует весь процесс обработки запроса. Вот как они взаимодействуют:
	Получение запроса:
	-DispatcherServlet получает HTTP-запрос от клиента (браузера, мобильного приложения и т.д.)
	-Определение контроллера:
		DispatcherServlet консультируется с HandlerMapping чтобы определить, какой контроллер должен обработать запрос
		Основано на URL пути и аннотациях (@RequestMapping, @GetMapping и др.)
	-Вызов контроллера:
		DispatcherServlet передает управление соответствующему методу контроллера
		Параметры метода связываются с данными запроса (параметры, тело, заголовки)
	-Обработка в контроллере:
		Контроллер выполняет свою логику
		Может взаимодействовать с сервисами и репозиториями
		Подготавливает данные модели
	-Возврат результата:
		Контроллер возвращает имя представления, объект ResponseEntity или DTO
		DispatcherServlet использует ViewResolver для определения View
		Для REST-контроллеров (@RestController) результат сериализуется в JSON/XML
	-Формирование ответа:
		DispatcherServlet отправляет ответ клиенту
	Ключевые моменты взаимодействия:
	DispatcherServlet — это "главный диспетчер", а контроллеры — "специализированные обработчики"
		Один DispatcherServlet может работать с множеством контроллеров
		DispatcherServlet делегирует конкретную обработку контроллерам
		Контроллеры не знают о DispatcherServlet — они просто возвращают данные
		DispatcherServlet обеспечивает единую точку входа для всех запросов
	
3. Что такое стереотипные аннотации? Какие они бывают?
	Стереотипные аннотации (Stereotype Annotations) — это специальные аннотации Spring, которые помечают классы как компоненты, 
	участвующие в управлении контейнером IoC (Inversion of Control). Они позволяют Spring автоматически обнаруживать (@ComponentScan)
	и регистрировать бины в ApplicationContext.
	Основные стереотипные аннотации : 
	@Component(Используется для любых компонентов, не подпадающих под более специализированные аннотации.), 
	@Service(Используется для классов бизнес-логики (сервисный слой).), 
	@Repository (Специализированная версия @Component для классов доступа к данным (DAO)), Автоматически преобразует исключения JDBC/Hibernate/JPA в DataAccessException.
	@Controller (Специализированная версия @Component для веб-слоя (Spring MVC)), Обрабатывает HTTP-запросы и возвращает представления (View) или данные (REST).
	@RestController (Используется для REST API (возвращает JSON/XML, а не HTML-представления))
	@Configuration Используется для Java-based конфигурации (вместо XML).
	Как работают стереотипные аннотации:
	 1. Сканирование компонентов (@ComponentScan) Spring ищет классы с @Component (и её производными) в указанных пакетах.
	 2. Создание бинов  Найденные классы регистрируются в ApplicationContext как Spring-бины.
	 3. Автопроводка зависимостей (@Autowired)  Spring автоматически внедряет зависимости между бинами.
	 
4. Что такое DI? Как он реализован в Spring?
	Dependency Injection (DI) — это паттерн проектирования, при котором зависимости (объекты, требуемые классу) 
	не создаются внутри класса, а "внедряются" извне. Это делает код более гибким, тестируемым и поддерживаемым.
	Архитектура приложения
	Наше приложение состоит из трёх слоёв:
	Контроллеры — слой представления:	VacancyController.	
	Сервисы — слой бизнес-логики:	VacancyService.	
	Репозитории — слой работы с данными:	VacancyRepository.
	В изначальной реализации используется шаблон проектирования Singleton для управления доступом к объектам классов. Однако этот подход имеет ограничения
	Решение с помощью Spring
	Spring берёт на себя управление созданием объектов и внедрением зависимостей. Вместо ручного управления мы можем использовать аннотации для автоматического связывания:

	@Controller — для слоя контроллеров.
	@Service — для слоя бизнес-логики.
	@Repository — для слоя работы с данными.
	Spring автоматически создаёт экземпляры классов и управляет ими в своём контейнере (контексте). Это называется Inversion of Control (IoC).
		
5. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam
	1. @ModelAttribute:
		Связывает параметры HTTP-запроса (формы, JSON, query-параметры) с объектом модели.
		Может использоваться на уровне метода (для подготовки данных) или на уровне аргумента (для привязки данных).
	2. @PathVariable: 
		Извлекает значение из URL-пути (например, /users/{id}).
	3. @RequestParam:
		Извлекает query-параметры из URL (например, /search?query=spring).
		
	Когда что использовать:
		@ModelAttribute — если нужно связать группу полей (например, форму) с объектом.
		@PathVariable — для динамических значений в URL (ID, slug).
		@RequestParam — для фильтрации, пагинации, поиска (параметры запроса).
		
6. Опишите аннотации @GetMapping, @PostMapping.
	В Spring MVC аннотации @GetMapping и @PostMapping используются для обработки HTTP-запросов разных типов (GET, POST и другие). 
		Они являются частью аннотаций @RequestMapping, но предоставляют более удобный и читаемый способ настройки эндпоинтов.
		1. @GetMapping - Обрабатывает HTTP GET-запросы. Используется для получения данных (например, загрузка страницы, получение списка объектов).
		2. @PostMapping - Обрабатывает HTTP POST-запросы. Используется для отправки данных (например, формы, JSON).
		Когда что использовать?
			@GetMapping – когда нужно получить данные (страницы, API-запросы без модификации данных).
			@PostMapping – когда нужно отправить данные (регистрация, загрузка файлов, REST API).
			
			
++++++++++++++++++++++++++++++++Многопоточность:+++++++++++++++++++++++++++++++++++++++++
1. Объясните, где в веб приложении появляется многопоточность?
	Многопоточность в веб-приложениях возникает:
		- На уровне сервера (обработка запросов).
		-В асинхронных операциях (@Async, CompletableFuture).
		-При работе с БД и внешними API.
		-В фоновых задачах (@Scheduled).
		-В долгоживущих соединениях (WebSockets/SSE).
	Для корректной работы важно:
		-Использовать пулы потоков.
		-Избегать состояния гонки.
		-Тестировать под нагрузкой.
		
2. Как создать дедлок (deadlock) в сервлете?
	Допустим, у нас есть два сервлета, которые вызывают друг друга с блокировкой ресурсов.
	Сценарий:
	-Поток 1 захватывает Resource A и пытается получить Resource B.
	-Поток 2 захватывает Resource B и пытается получить Resource A.
	-Оба потока ждут друг друга → дедлок.
	
4. Как решать проблемы многопоточности на уровне базы данных?
	за обеспечение уникальности будет нести ответственность СУБД. 
	Для этого нам нужно добавить ограничение уникальности на поле email. Можно это сделать прям при создании таблицы:
	CREATE TABLE users
	(
		id       SERIAL PRIMARY KEY,
		email    varchar unique not null,
		password varchar not null
	);
	Тогда Если две параллельные транзакции будут выполнять запрос с одинаковой почтой, то та, что будет быстрее выполниться, 
	а вторая вернется с ошибкой ConstrainsViolationException.
	INSERT INTO users (email) VALUES ('user@ya.ru'); -- сохранить данные.
	INSERT INTO users (email) VALUES ('user@ya.ru'); -- вернется с ошибкой ConstrainsViolationException.
	
	
++++++++++++++++++++++++++++++Архитектура:++++++++++++++++++++++++++++

1. Объясните слоеную архитектуру.
	Любое веб приложение можно представить в виде слоеного пирога.
	-Слой контроллеры - это классы для работы с клиентом. Эти классы принимают запросы и отдают ответы от клиента. 
	-Слой сервисы - это классы, выполняющие бизнес логику приложения. В слое сервисов используется только бизнес логика. 
		Здесь не должно быть работы с базой данных или c HTML. На качественно написанный слой сервисов легко написать модульные тесты, 
		потому что у нас нет привязки к внешним ресурсам. 
	-Слой персистенции - это классы для работы с базами данных. 
	
2. Объясните шаблон MVC на примере Servlet.
	MVC (Model-View-Controller) — это архитектурный паттерн, разделяющий приложение на три компонента:
	-Model (модель) — данные и бизнес-логика.
	-View (представление) — отображение данных (JSP, Thymeleaf).
	-Controller (контроллер) — обработка запросов и управление потоком (Servlet).
	
3. Объясните шаблон MVC на примере Spring boot.
	MVC (Model-View-Controller) в Spring Boot — это стандартный способ организации кода, где:
	Model — данные и бизнес-логика. Класс-сущность (DTO или JPA Entity), представляющий данные.
	View — отображение (HTML, Thymeleaf, JSP). HTML-шаблон с использованием Thymeleaf.
	Controller — обработка HTTP-запросов. Обрабатывает запросы и возвращает View или данные.


+++++++++++++++++++++++++++++++База данных.++++++++++++++++++++++++++++
1. Зачем нужен пул соединений?
	Почему нужен пул? Напомню, что все запросы от клиентов обрабатываются в отдельных нитях. 
	По умолчанию в Tomcat используется 200 нитей для обработки запросов. Если мы будем использовать одно соединение с базой данных, 
	то остальные нити будут ждать завершения работы с базой данных, а для веб приложений такая ситуация неприемлема.

	Запомните, что веб приложения - это многопоточные приложения, где блокировать работу пользователя нельзя.
	------------------------------------
	BasicDataSource cp = .... - пул соединений.
	ConnectionProxy connection = cp.getConnnection() - получаем соединение с базой из многопоточной очереди. 
	То есть вызываем метод queue.poll(). В очереди больше нет Объект ConnectionProxу.
	connection - работаем с соединением.
	connection.close() - завершаем работу. Вызов метода close у прокси возвращает соединение в очередь, но не закрываем его.
	Так мы можем переиспользовать соединения.
	---------------------------------
	
	
+++++++++++++++++++++++++++++++++++++++++++++++Безопасность.++++++++++++++++++++++++++++++++++++++++
1. Что такое HttpSession?
	HttpSession — это механизм в Java EE и Spring, который позволяет сохранять данные пользователя между несколькими HTTP-запросами. 
	Он работает на стороне сервера и использует куки (JSESSIONID) или URL-перезапись для идентификации сессии.
	
	Сессия — это временное хранилище данных на сервере, связанное с конкретным пользователем.
	JSESSIONID — уникальный идентификатор сессии, передаваемый в куках или URL.
	Время жизни — сессия может быть уничтожена после истечения таймаута или при logout.
	----------------------------------
	@WebServlet("/login")
	public class LoginServlet extends HttpServlet {
		protected void doPost(HttpServletRequest request, HttpServletResponse response) {
			HttpSession session = request.getSession(); // Получаем сессию (или создаём новую)
			session.setAttribute("username", request.getParameter("username"));
		}
	}
	-----------------------------------------------

2. Что такое авторизация?
	Авторизация — это процесс проверки прав пользователя на выполнение определённых действий или доступ к ресурсам в системе после его аутентификации (подтверждения личности).
	
3. Что такое аутентификация?
	Аутентификация — это процесс подтверждения личности пользователя (или системы), чтобы удостовериться, что он действительно тот, за кого себя выдаёт.
	Способы : Логин и пароль. Отпечаток пальца или Face ID. Одноразовый код из SMS.
	
4. Что такое cookie?
	Cookie (куки) — это небольшие текстовые данные (до 4 КБ), которые веб-сервер отправляет браузеру, 
	а браузер сохраняет их и автоматически пересылает обратно при каждом последующем запросе к этому серверу.
	Это как «визитка», которую сайт оставляет в вашем браузере, чтобы узнавать вас при следующем посещении.
	Используется:
		Аутентификация — сохранение логина/сессии (например, JSESSIONID).
		Персонализация — настройки языка, темы, локации.
		Трекинг — аналитика поведения пользователя (Google Analytics).
		Корзины покупок — временное хранение товаров в интернет-магазинах.

