Источники https://habr.com/ru/companies/simbirsoft/articles/812097/
https://habr.com/ru/companies/piter/articles/451322/

1. Чем отличается процесс от потока?
1. Чем отличается процесс от потока?
Процесс — это экземпляр выполняющейся программы. Каждый процесс обладает своим собственным адресным пространством и ресурсами, 
такими как файлы и сетевые соединения. По сути это изолированный контейнер, в котором выполняется код программы.

Поток (или поток выполнения) — более легковесная единица выполнения, существующая внутри процесса. В одном процессе может существовать
 несколько потоков, которые могут параллельно выполнять инструкции программы. В отличие от процессов, потоки внутри одного процесса совместно используют его ресурсы.

2. Каким образом можно создать поток?
	Способы создания и запуса потоков
	1. Когда вы наследуете от класса Thread, вы создаете новый класс, который переопределяет метод run(). 
		Затем вы создаете экземпляр этого класса и вызываете метод start() для запуска потока.
			class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
				}
			}
	2. Интерфейс Runnable  -Второй способ создания потока — имплементирование интерфейса Runnable.
		class MyRunnable implements Runnable {
			@Override
			public void run() {
				System.out.println("Поток выполняется через Runnable");
			}
		}

		public class Main {
			public static void main(String[] args) {
				MyRunnable myRunnable = new MyRunnable();
				Thread thread = new Thread(myRunnable);
				thread.start();
			}
		}
		Этот метод имеет ряд преимуществ по сравнению с созданием потока через Thread:
		- Гибкость в наследовании
		- Легкая реорганизация кода
		- Разделение задач
		- Повышение многократного использования
		- не предоставляет способа возвращать результат выполнения задачи.
		- Runnable не бросает проверяемые исключения (за исключением тех, которые являются подклассами RuntimeException).
	3. Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
	 Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и 
	 проблем, связанных с одновременным доступом к общим ресурсам.
	 
	Состояния потоков
	Потоки могут пребывать в нескольких состояниях:
	New – когда создается экземпляр класса Thread, поток находится в состоянии new. Он пока еще не работает.
	Running — поток запущен и процессор начинает его выполнение. Во время выполнения состояние потока также может измениться на Runnable, Dead или Blocked.
	Suspended — запущенный поток приостанавливает свою работу, затем можно возобновить его выполнение. Поток начнет работать с того места, где его остановили.
	Blocked — поток ожидает высвобождения ресурсов или завершение операции ввода-вывода. Находясь в этом состоянии поток не потребляет процессорное время.
	Terminated — поток немедленно завершает свое выполнение. Его работу нельзя возобновить. Причинами завершения потока могут быть ситуации, когда код потока 
		полностью выполнен или во время выполнения потока произошла ошибка (например, ошибка сегментации или необработанного исключения).
	Dead — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл.

	Жизненный цикл потоков в Java
	1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
		 необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

	2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
		Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

	3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
		В этот момент код, содержащийся в методе run(), начинает выполняться.

	4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
		ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

	5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
		Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
		После завершения выполнения поток больше не может быть запущен.

3. Как работают методы sleep, yield, wait, notify и notifyAll?
	В Java методы sleep, yield, wait, notify и notifyAll используются для управления потоками (threads) и их синхронизацией. 
	Каждый из этих методов выполняет определенную задачу, связанную с управлением выполнением потоков.
	sleep: Для приостановки потока на определенное время.
	yield: Для уступки процессорного времени другим потокам.
	wait, notify, notifyAll: Для синхронизации потоков и управления доступом к общим ресурсам.


	Сравнение методов:
	Метод	Состояние потока	Освобождает монитор	Вызывается в synchronized	Прерываемый
	sleep()	TIMED_WAITING		Нет					Нет							Да
	yield()	RUNNABLE			Нет					Нет							Нет
	wait()	WAITING				Да					Да							Да
	notify()	-				Нет					Да							Нет
	notifyAll()	-				Нет					Да							Нет
	
	Метод sleep приостанавливает выполнение текущего потока на указанное количество миллисекунд. 
		Поток переходит в состояние TIMED_WAITING, но при этом не освобождает монитор (если он был захвачен).
	Метод yield предлагает планировщику потоков (thread scheduler) переключиться на другой поток, который готов к выполнению. 
		Это способ "уступить" процессорное время другим потокам.
	Метод wait используется для приостановки текущего потока до тех пор, пока другой поток не вызовет notify() или notifyAll() для того же объекта. 
		Поток переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания).
	Метод notify пробуждает один поток, который находится в состоянии ожидания (вызвав wait() на том же объекте). 
		Если несколько потоков ожидают, то выбор конкретного потока зависит от планировщика.
	Метод notifyAll пробуждает все потоки, которые находятся в состоянии ожидания (вызвав wait() на том же объекте). 
		После этого все потоки начнут конкурировать за монитор.

4. Объясните следующие термины: монитор, мьютекс, критическая секция.
	Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. 
		Только один поток может находиться в мониторе объекта в любой момент времени.
		Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.
2. Каким образом можно создать поток?
	Способы создания и запуса потоков
	1. Когда вы наследуете от класса Thread, вы создаете новый класс, который переопределяет метод run(). 
		Затем вы создаете экземпляр этого класса и вызываете метод start() для запуска потока.
			class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
				}
			}
	2. Интерфейс Runnable  -Второй способ создания потока — имплементирование интерфейса Runnable.
		class MyRunnable implements Runnable {
			@Override
			public void run() {
				System.out.println("Поток выполняется через Runnable");
			}
		}

		public class Main {
			public static void main(String[] args) {
				MyRunnable myRunnable = new MyRunnable();
				Thread thread = new Thread(myRunnable);
				thread.start();
			}
		}
		Этот метод имеет ряд преимуществ по сравнению с созданием потока через Thread:
		- Гибкость в наследовании
		- Легкая реорганизация кода
		- Разделение задач
		- Повышение многократного использования
		- не предоставляет способа возвращать результат выполнения задачи.
		- Runnable не бросает проверяемые исключения (за исключением тех, которые являются подклассами RuntimeException).
	3. Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
	 Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и 
	 проблем, связанных с одновременным доступом к общим ресурсам.
	 
	Состояния потоков
	Потоки могут пребывать в нескольких состояниях:
	New – когда создается экземпляр класса Thread, поток находится в состоянии new. Он пока еще не работает.
	Running — поток запущен и процессор начинает его выполнение. Во время выполнения состояние потока также может измениться на Runnable, Dead или Blocked.
	Suspended — запущенный поток приостанавливает свою работу, затем можно возобновить его выполнение. Поток начнет работать с того места, где его остановили.
	Blocked — поток ожидает высвобождения ресурсов или завершение операции ввода-вывода. Находясь в этом состоянии поток не потребляет процессорное время.
	Terminated — поток немедленно завершает свое выполнение. Его работу нельзя возобновить. Причинами завершения потока могут быть ситуации, когда код потока 
		полностью выполнен или во время выполнения потока произошла ошибка (например, ошибка сегментации или необработанного исключения).
	Dead — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл.

	Жизненный цикл потоков в Java
	1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
		 необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

	2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
		Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

	3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
		В этот момент код, содержащийся в методе run(), начинает выполняться.

	4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
		ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

	5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
		Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
		После завершения выполнения поток больше не может быть запущен.

3. Как работают методы sleep, yield, wait, notify и notifyAll?
	В Java методы sleep, yield, wait, notify и notifyAll используются для управления потоками (threads) и их синхронизацией. 
	Каждый из этих методов выполняет определенную задачу, связанную с управлением выполнением потоков.
	sleep: Для приостановки потока на определенное время.
	yield: Для уступки процессорного времени другим потокам.
	wait, notify, notifyAll: Для синхронизации потоков и управления доступом к общим ресурсам.


	Сравнение методов:
	Метод	Состояние потока	Освобождает монитор	Вызывается в synchronized	Прерываемый
	sleep()	TIMED_WAITING		Нет					Нет							Да
	yield()	RUNNABLE			Нет					Нет							Нет
	wait()	WAITING				Да					Да							Да
	notify()	-				Нет					Да							Нет
	notifyAll()	-				Нет					Да							Нет
	
	Метод sleep приостанавливает выполнение текущего потока на указанное количество миллисекунд. 
		Поток переходит в состояние TIMED_WAITING, но при этом не освобождает монитор (если он был захвачен).
	Метод yield предлагает планировщику потоков (thread scheduler) переключиться на другой поток, который готов к выполнению. 
		Это способ "уступить" процессорное время другим потокам.
	Метод wait используется для приостановки текущего потока до тех пор, пока другой поток не вызовет notify() или notifyAll() для того же объекта. 
		Поток переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания).
	Метод notify пробуждает один поток, который находится в состоянии ожидания (вызвав wait() на том же объекте). 
		Если несколько потоков ожидают, то выбор конкретного потока зависит от планировщика.
	Метод notifyAll пробуждает все потоки, которые находятся в состоянии ожидания (вызвав wait() на том же объекте). 
		После этого все потоки начнут конкурировать за монитор.

4. Объясните следующие термины: монитор, мьютекс, критическая секция.
	Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. 
		Только один поток может находиться в мониторе объекта в любой момент времени.
		Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.

	Критическая секция — участок кода, в котором выполняются операции над общими ресурсами. Внутри критической секции поток захватывает 
		монитор объекта, чтобы гарантировать взаимное исключение.
		
5. Как работает join()?
	Метод join() — это удобный способ синхронизации потоков, позволяющий одному потоку дождаться завершения другого. 
		Он особенно полезен в сценариях, где порядок выполнения потоков имеет значение.
	Метод join() в Java используется для того, чтобы один поток мог дождаться завершения выполнения другого потока. Когда поток вызывает join() для другого потока, 
		он переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания) и ждет, пока целевой поток завершит свою работу.
		class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
					// Основной поток ждет завершения потока myThread
					myThread.join();
				}
			}
			
6. Что такое DeadLock? Приведите примеры.
	Взаимоблокировка (Deadlock) Взаимоблокировка возникает, когда два или более потока удерживают ресурсы и ждут друг друга для освобождения ресурсов, 
		необходимых другим потокам. Как результат – ни один из потоков не может продолжить выполнение и программа оказывается заблокированной.
		
		Для возникновения взаимной блокировки необходимо выполнение следующих четырех условий (условия Коффмана):
		-Взаимное исключение (Mutual Exclusion):
			Ресурсы, которые используют потоки, не могут быть разделены между ними. Только один поток может владеть ресурсом в любой момент времени.
		-Удержание и ожидание (Hold and Wait):
			Поток удерживает один ресурс и одновременно ожидает освобождения другого ресурса, захваченного другим потоком.
		-Отсутствие вытеснения (No Preemption):
			Ресурсы нельзя отобрать у потока. Только поток, владеющий ресурсом, может его освободить.
		-Круговая зависимость (Circular Wait):
			Потоки образуют замкнутый круг, где каждый поток ожидает ресурс, удерживаемый следующим потоком в цепи.
			
		Как избежать Deadlock:
		-Упорядоченное захватывание ресурсов:
			Всегда захватывайте ресурсы в одном и том же порядке. Например, в примере выше можно захватывать сначала resource1, а затем resource2 в обоих потоках.
		-Использование тайм-аутов:
			Используйте методы с тайм-аутом, такие как tryLock() из java.util.concurrent.locks.ReentrantLock, чтобы избежать бесконечного ожидания.
		-Разрушение условий Deadlock:
			Нарушьте одно из условий Коффмана. Например, можно использовать вытеснение ресурсов или избегать удержания ресурсов при ожидании других.
		-Использование высокоуровневых инструментов:
			Используйте библиотеки и инструменты для работы с многопоточностью, такие как java.util.concurrent, которые помогают избегать Deadlock.
			

7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
	В Java для работы с потоко-безопасными (thread-safe) ассоциативными массивами (map) можно использовать два основных подхода: Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap. 
		Оба подхода обеспечивают потокобезопасность, но делают это по-разному, что влияет на их производительность и поведение. Рассмотрим их различия.
			1. Collections.synchronizedMap(new HashMap())
				Этот метод создает синхронизированную обертку вокруг обычного HashMap. 
					Вся работа с картой синхронизируется на уровне метода, что делает ее потокобезопасной.
				Синхронизация:
				Каждый метод карты (например, put, get, remove) синхронизирован на уровне объекта-обертки.
				Это означает, что только один поток может выполнять операции с картой в любой момент времени.
				Пример:
					Map<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
				Преимущества:
					Простота использования.
					Гарантирует потокобезопасность для всех операций.
				Недостатки:
					Низкая производительность при высокой конкуренции, так как все операции блокируют всю карту.
					Нет поддержки атомарных операций (например, putIfAbsent).
			2. ConcurrentHashMap — это специализированная потокобезопасная реализация интерфейса Map, которая использует более сложный механизм синхронизации для повышения производительности.
				Синхронизация:
				Внутренняя структура ConcurrentHashMap разделена на сегменты (в более старых версиях) 
					или использует CAS (Compare-And-Swap) операции и блокировки на уровне отдельных ячеек (в новых версиях).
				Это позволяет нескольким потокам одновременно читать и даже изменять карту, если они работают с разными сегментами или ячейками.
				Пример:
					Map<String, String> concurrentHashMap = new ConcurrentHashMap<>();
				Преимущества:
					Высокая производительность при высокой конкуренции, так как блокировки применяются только к отдельным сегментам или ячейкам.
					Поддержка атомарных операций, таких как putIfAbsent, compute, merge и других.
					Не блокирует всю карту при выполнении операций.
				Недостатки:
					Более сложная реализация.
					Нет гарантии строгой консистентности (например, при итерации карты могут быть видны частично выполненные изменения).
					
8. Различия в интерфейсах Runnable и Callable.
	Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
		Runnable — это простой интерфейс для задач, которые не возвращают результат и не выбрасывают проверяемые исключения.
		Callable — это более мощный интерфейс, который позволяет возвращать результат и выбрасывать исключения.
			Он используется вместе с ExecutorService и Future для управления выполнением задач и получения результатов.
			
9. Различия между isInterrupted(), interrupted(), interrupt().
	В Java методы isInterrupted(), interrupted() и interrupt() связаны с управлением состоянием прерывания потока. Они используются для проверки и изменения состояния флага прерывания потока.
		Однако между ними есть важные различия, которые важно понимать для корректной работы с многопоточностью.
		1. interrupt()используется для установки флага прерывания потока. Если поток находится в состоянии ожидания 
			(например, вызвал sleep(), wait(), join()), то вызов interrupt() выбросит исключение InterruptedException.
		2. isInterrupted() проверяет, был ли установлен флаг прерывания для потока. Этот метод не сбрасывает флаг прерывания.
		3. interrupted() — это статический метод класса Thread, который проверяет, был ли установлен флаг прерывания для текущего потока. 
			В отличие от isInterrupted(), этот метод сбрасывает флаг прерывания после проверки.
	
		Основные различия:
			Метод			Тип метода		Сбрасывает флаг прерывания	Проверяемый поток
			interrupt()		Нестатический	Нет							Любой поток
			isInterrupted()	Нестатический	Нет							Любой поток
			interrupted()	Статический		Да							Текущий поток

10. Что происходит при вызове Thread.interrupt()?
	Устанавливает флаг прерывания потока.
	Если поток находится в состоянии ожидания, выбрасывает InterruptedException.
	Не останавливает поток немедленно — поток должен сам проверить флаг прерывания и завершить выполнение.

11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.


12. Назовите отличия synchronized{} и ReentrantLock.

13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.

14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.

15. Расскажите про Exchanger.

16. Отличие Thread.start() и Thread.run()?

17. Объясните ключевое слово volatile.

18. Расскажите про приоритеты потока

19. Что такое потоки-демоны?

20. Назовите все возможные состояния потока

21. Что такое race condition?

22. Что такое Thread Local переменная? 

23. Что такое FutureTask?

24. Что такое Thread Pool?

25. Что такое Semaphore?

26. Чем отличается submit от execute у ExecutorService?

27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

29. Что такое ReadWriteLock?

30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

31. Расскажите про шаблон проектирования Producer Consumer.

32. Как можно запустить параллельный поток (parallelStream)?

33. Что делают методы parallel и sequential?

34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.

35. В чем разница между методами forEach и forEachOrdered?

36. В чем разница между применением метода peek() в последовательном и параллельном потоках?

37. Что делает метод unordered?

38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?

39. Расскажите про Java NIO и её главные составляющие.

40. Что такое канал?

41. Что такое буфер?

42. Что такое селектор?

43. Когда есть смысл использовать Java NIO?

44. Что такое PipedStreams? Как они устроены?
