Источники https://habr.com/ru/companies/simbirsoft/articles/812097/
https://habr.com/ru/companies/piter/articles/451322/

1. Чем отличается процесс от потока?
Процесс — это экземпляр выполняющейся программы. Каждый процесс обладает своим собственным адресным пространством и ресурсами, 
такими как файлы и сетевые соединения. По сути это изолированный контейнер, в котором выполняется код программы.

Поток (или поток выполнения) — более легковесная единица выполнения, существующая внутри процесса. В одном процессе может существовать
 несколько потоков, которые могут параллельно выполнять инструкции программы. В отличие от процессов, потоки внутри одного процесса совместно используют его ресурсы.

2. Каким образом можно создать поток?
	Способы создания и запуса потоков
	1. Когда вы наследуете от класса Thread, вы создаете новый класс, который переопределяет метод run(). 
		Затем вы создаете экземпляр этого класса и вызываете метод start() для запуска потока.
			class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
				}
			}
	2. Интерфейс Runnable  -Второй способ создания потока — имплементирование интерфейса Runnable.
		class MyRunnable implements Runnable {
			@Override
			public void run() {
				System.out.println("Поток выполняется через Runnable");
			}
		}

		public class Main {
			public static void main(String[] args) {
				MyRunnable myRunnable = new MyRunnable();
				Thread thread = new Thread(myRunnable);
				thread.start();
			}
		}
		Этот метод имеет ряд преимуществ по сравнению с созданием потока через Thread:
		- Гибкость в наследовании
		- Легкая реорганизация кода
		- Разделение задач
		- Повышение многократного использования
		- не предоставляет способа возвращать результат выполнения задачи.
		- Runnable не бросает проверяемые исключения (за исключением тех, которые являются подклассами RuntimeException).
	3. Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
	 Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и 
	 проблем, связанных с одновременным доступом к общим ресурсам.
	 
	Состояния потоков
	Потоки могут пребывать в нескольких состояниях:
	New – когда создается экземпляр класса Thread, поток находится в состоянии new. Он пока еще не работает.
	Running — поток запущен и процессор начинает его выполнение. Во время выполнения состояние потока также может измениться на Runnable, Dead или Blocked.
	Suspended — запущенный поток приостанавливает свою работу, затем можно возобновить его выполнение. Поток начнет работать с того места, где его остановили.
	Blocked — поток ожидает высвобождения ресурсов или завершение операции ввода-вывода. Находясь в этом состоянии поток не потребляет процессорное время.
	Terminated — поток немедленно завершает свое выполнение. Его работу нельзя возобновить. Причинами завершения потока могут быть ситуации, когда код потока 
		полностью выполнен или во время выполнения потока произошла ошибка (например, ошибка сегментации или необработанного исключения).
	Dead — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл.

	Жизненный цикл потоков в Java
	1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
		 необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

	2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
		Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

	3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
		В этот момент код, содержащийся в методе run(), начинает выполняться.

	4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
		ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

	5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
		Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
		После завершения выполнения поток больше не может быть запущен.

3. Как работают методы sleep, yield, wait, notify и notifyAll?
	В Java методы sleep, yield, wait, notify и notifyAll используются для управления потоками (threads) и их синхронизацией. 
	Каждый из этих методов выполняет определенную задачу, связанную с управлением выполнением потоков.
	sleep: Для приостановки потока на определенное время.
	yield: Для уступки процессорного времени другим потокам.
	wait, notify, notifyAll: Для синхронизации потоков и управления доступом к общим ресурсам.


	Сравнение методов:
	Метод	Состояние потока	Освобождает монитор	Вызывается в synchronized	Прерываемый
	sleep()	TIMED_WAITING		Нет					Нет							Да
	yield()	RUNNABLE			Нет					Нет							Нет
	wait()	WAITING				Да					Да							Да
	notify()	-				Нет					Да							Нет
	notifyAll()	-				Нет					Да							Нет
	
	Метод sleep приостанавливает выполнение текущего потока на указанное количество миллисекунд. 
		Поток переходит в состояние TIMED_WAITING, но при этом не освобождает монитор (если он был захвачен).
	Метод yield предлагает планировщику потоков (thread scheduler) переключиться на другой поток, который готов к выполнению. 
		Это способ "уступить" процессорное время другим потокам.
	Метод wait используется для приостановки текущего потока до тех пор, пока другой поток не вызовет notify() или notifyAll() для того же объекта. 
		Поток переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания).
	Метод notify пробуждает один поток, который находится в состоянии ожидания (вызвав wait() на том же объекте). 
		Если несколько потоков ожидают, то выбор конкретного потока зависит от планировщика.
	Метод notifyAll пробуждает все потоки, которые находятся в состоянии ожидания (вызвав wait() на том же объекте). 
		После этого все потоки начнут конкурировать за монитор.

4. Объясните следующие термины: монитор, мьютекс, критическая секция.
	Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. 
		Только один поток может находиться в мониторе объекта в любой момент времени.
		Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.

	Критическая секция — участок кода, в котором выполняются операции над общими ресурсами. Внутри критической секции поток захватывает 
		монитор объекта, чтобы гарантировать взаимное исключение.
		
5. Как работает join()?
	Метод join() — это удобный способ синхронизации потоков, позволяющий одному потоку дождаться завершения другого. 
		Он особенно полезен в сценариях, где порядок выполнения потоков имеет значение.
	Метод join() в Java используется для того, чтобы один поток мог дождаться завершения выполнения другого потока. Когда поток вызывает join() для другого потока, 
		он переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания) и ждет, пока целевой поток завершит свою работу.
		class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
					// Основной поток ждет завершения потока myThread
					myThread.join();
				}
			}
			
6. Что такое DeadLock? Приведите примеры.
	Взаимоблокировка (Deadlock) Взаимоблокировка возникает, когда два или более потока удерживают ресурсы и ждут друг друга для освобождения ресурсов, 
		необходимых другим потокам. Как результат – ни один из потоков не может продолжить выполнение и программа оказывается заблокированной.
		
		Для возникновения взаимной блокировки необходимо выполнение следующих четырех условий (условия Коффмана):
		-Взаимное исключение (Mutual Exclusion):
			Ресурсы, которые используют потоки, не могут быть разделены между ними. Только один поток может владеть ресурсом в любой момент времени.
		-Удержание и ожидание (Hold and Wait):
			Поток удерживает один ресурс и одновременно ожидает освобождения другого ресурса, захваченного другим потоком.
		-Отсутствие вытеснения (No Preemption):
			Ресурсы нельзя отобрать у потока. Только поток, владеющий ресурсом, может его освободить.
		-Круговая зависимость (Circular Wait):
			Потоки образуют замкнутый круг, где каждый поток ожидает ресурс, удерживаемый следующим потоком в цепи.
			
		Как избежать Deadlock:
		-Упорядоченное захватывание ресурсов:
			Всегда захватывайте ресурсы в одном и том же порядке. Например, в примере выше можно захватывать сначала resource1, а затем resource2 в обоих потоках.
		-Использование тайм-аутов:
			Используйте методы с тайм-аутом, такие как tryLock() из java.util.concurrent.locks.ReentrantLock, чтобы избежать бесконечного ожидания.
		-Разрушение условий Deadlock:
			Нарушьте одно из условий Коффмана. Например, можно использовать вытеснение ресурсов или избегать удержания ресурсов при ожидании других.
		-Использование высокоуровневых инструментов:
			Используйте библиотеки и инструменты для работы с многопоточностью, такие как java.util.concurrent, которые помогают избегать Deadlock.
			

7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
	В Java для работы с потоко-безопасными (thread-safe) ассоциативными массивами (map) можно использовать два основных подхода: Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap. 
		Оба подхода обеспечивают потокобезопасность, но делают это по-разному, что влияет на их производительность и поведение. Рассмотрим их различия.
			1. Collections.synchronizedMap(new HashMap())
				Этот метод создает синхронизированную обертку вокруг обычного HashMap. 
					Вся работа с картой синхронизируется на уровне метода, что делает ее потокобезопасной.
				Синхронизация:
				Каждый метод карты (например, put, get, remove) синхронизирован на уровне объекта-обертки.
				Это означает, что только один поток может выполнять операции с картой в любой момент времени.
				Пример:
					Map<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
				Преимущества:
					Простота использования.
					Гарантирует потокобезопасность для всех операций.
				Недостатки:
					Низкая производительность при высокой конкуренции, так как все операции блокируют всю карту.
					Нет поддержки атомарных операций (например, putIfAbsent).
			2. ConcurrentHashMap — это специализированная потокобезопасная реализация интерфейса Map, которая использует более сложный механизм синхронизации для повышения производительности.
				Синхронизация:
				Внутренняя структура ConcurrentHashMap разделена на сегменты (в более старых версиях) 
					или использует CAS (Compare-And-Swap) операции и блокировки на уровне отдельных ячеек (в новых версиях).
				Это позволяет нескольким потокам одновременно читать и даже изменять карту, если они работают с разными сегментами или ячейками.
				Пример:
					Map<String, String> concurrentHashMap = new ConcurrentHashMap<>();
				Преимущества:
					Высокая производительность при высокой конкуренции, так как блокировки применяются только к отдельным сегментам или ячейкам.
					Поддержка атомарных операций, таких как putIfAbsent, compute, merge и других.
					Не блокирует всю карту при выполнении операций.
				Недостатки:
					Более сложная реализация.
					Нет гарантии строгой консистентности (например, при итерации карты могут быть видны частично выполненные изменения).
					
8. Различия в интерфейсах Runnable и Callable.
	Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
		Runnable — это простой интерфейс для задач, которые не возвращают результат и не выбрасывают проверяемые исключения.
		Callable — это более мощный интерфейс, который позволяет возвращать результат и выбрасывать исключения.
			Он используется вместе с ExecutorService и Future для управления выполнением задач и получения результатов.
			
9. Различия между isInterrupted(), interrupted(), interrupt().
	В Java методы isInterrupted(), interrupted() и interrupt() связаны с управлением состоянием прерывания потока. Они используются для проверки и изменения состояния флага прерывания потока.
		Однако между ними есть важные различия, которые важно понимать для корректной работы с многопоточностью.
		1. interrupt()используется для установки флага прерывания потока. Если поток находится в состоянии ожидания 
			(например, вызвал sleep(), wait(), join()), то вызов interrupt() выбросит исключение InterruptedException.
		2. isInterrupted() проверяет, был ли установлен флаг прерывания для потока. Этот метод не сбрасывает флаг прерывания.
		3. interrupted() — это статический метод класса Thread, который проверяет, был ли установлен флаг прерывания для текущего потока. 
			В отличие от isInterrupted(), этот метод сбрасывает флаг прерывания после проверки.
	
		Основные различия:
			Метод			Тип метода		Сбрасывает флаг прерывания	Проверяемый поток
			interrupt()		Нестатический	Нет							Любой поток
			isInterrupted()	Нестатический	Нет							Любой поток
			interrupted()	Статический		Да							Текущий поток



Synchronized — это ключевое слово в Java, которое используется для синхронизации потоков. Когда метод или блок кода помечается как 
synchronized, это означает, что только один поток может выполнять данный метод или блок кода на объекте в определенный момент времени.

Volatile – это ключевое слово, использующееся для переменных в Java. Когда переменная объявлена как volatile, это гарантирует, 
что операции чтения и записи к этой переменной выполняются атомарно (в одну операцию), и также гарантирует, что изменения переменной видны всем потокам.

Например: private volatile boolean flag = false;

Если один поток изменяет значение flag, это изменение сразу же становится видимым другим потокам. Без ключевого слова volatile, 
изменения могли бы задерживаться из-за кэширования переменных потоками.

Жизненный цикл потоков в Java
1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
     необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
    Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
    В этот момент код, содержащийся в методе run(), начинает выполняться.

4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
    ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
    Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
    После завершения выполнения поток больше не может быть запущен.

Виды потоков
1. Демон-потоки  - Демон-потоки работают в фоновом режиме и предназначены для выполнения служебных задач, 
    не являющихся критически важными для основной логики программы. Когда все не-демон-потоки завершают свою работу, 
    JVM автоматически завершает выполнение программы, независимо от того, завершились демон-потоки или нет.

2. Не-демон-потоки   -  Не-демон-потоки считаются основными потоками выполнения. Если есть хотя бы один не-демон-поток, 
    JVM будет ждать завершения всех не-демон-потоков перед завершением выполнения программы.

3. Виртуальные потоки  - Начиная с 16-й версии в Java появились виртуальные потоки. Давайте сравним их с традиционными:
    Виртуальные потоки являются более легковесными, потому что они не привязаны к нативным потокам ОС, 
    в то время как обычные потоки тяжеловесные, потому что каждый обычный поток соответствует нативному потоку внутри процесса.


4. Executors - В Java пакет java.util.concurrent имеется удобный способ управления потоками через интерфейсы Executor, 
    ExecutorService и фабрику Executors. Давайте рассмотрим их основные концепции и методы создания потоков:
    - Executor. Это простой интерфейс с единственным методом execute (Runnable command). Он предназначен для выполнения 
        переданного объекта Runnable, но не предоставляет методов для управления и контроля выполнения задач.
    - ExecutorService. Это многофункциональный интерфейс, расширяющий Executor. Предоставляет более продвинутый способ 
        управления выполнением задач и включает методы управления жизненным циклом потока. Некоторые из основных методов ExecutorService
    - Executors. Это фабрика для создания различных типов исполнителей (Executor и ExecutorService), 
        где есть методы для создания исполнителей с различными характеристиками.
5. ForkJoinPool - Это особый тип пула потоков в Java, предназначенный для выполнения рекурсивных задач и разбивающий их на более мелкие.
 Он введен в Java 7 и базируется на идее «разделяй и властвуй» (divide and conquer). ForkJoinPool используется в сочетании 
 с фреймворком Fork/Join (java.util.concurrent.ForkJoinTask и java.util.concurrent.RecursiveTask).
Основные концепции ForkJoinPool:
- Разделение (Forking). Задача разбивается на более мелкие подзадачи.
- Выполнение (Joining). Подзадачи выполняются параллельно в пуле потоков и их результаты объединяются в результат исходной задачи.
6. Parallel Stream
Parallel Stream это один из механизмов параллельной обработки данных в Java, введенный в Java 8 вместе с функциональным интерфейсом java.util.stream.Stream.
7. Atomic - пакет java.util.concurrent.atomic.В многопоточной программе атомарность гарантирует, 
    что выполнение определенной операции будет происходить как единое, неделимое действие. 
8. RxJava  - RxJava – библиотека для композиции асинхронных и событийно-ориентированных программ, основанная на концепциях реактивного программирования. 
    Это набор инструментов и типов данных для работы с потоками данных и событиями. В некотором смысле RxJava напоминает асинхронную версию Stream API. 
    Оба API дают возможность работать с последовательностями данных (или потоками данных), применять операции к этим данным и выполнять их.

    Рекомендации по выбору способа создания потоков
Thread:
Вы можете использовать класс Thread, когда требуется базовая функциональность создания потока и нет необходимости в дополнительных возможностях управления и синхронизации.
ForkJoinPool:
Для параллельного выполнения независимых подзадач и управления пулом потоков, рекомендуется использовать ForkJoinPool. 
Он особенно полезен для высокоуровневого параллельного программирования.
Runnable:
Используйте интерфейс Runnable для создания потоков, если необходимо выполнить асинхронную задачу без возвращаемого значения. 
Этот подход обеспечивает многократное использование кода и отделение логики потока от его управления.
ParallelStream:
При обработке больших объемов данных и выполнении операций над ними, рассмотрите параллельные потоки данных (ParallelStream). 
Они автоматически распределят выполнение операций между доступными потоками и ускорят обработку данных.
Callable:
Если нужно получить результат выполнения задачи или обработать исключение, выбирайте интерфейс Callable. Он позволяет вернуть 
значение из потока и бросить исключение в основной поток.
Atomic:
Для обеспечения безопасности доступа к общим ресурсам из нескольких потоков хорошо подходят классы из пакета 
java.util.concurrent.atomic: AtomicInteger, AtomicLong и другие.
Executors:
Для формирования пула потоков лучше всего подходит Executors, который предоставляет удобные методы для создания и управления потоками в приложении, 
что позволит избежать этого вручную.
RxJava:
Если нужна реализация реактивного программирования и работы с асинхронными потоками, выбирайте RxJava.
 Этот подход предоставляет мощные инструменты для работы с потоками и обработки асинхронных событий.
Каждый из вышеперечисленных подходов имеет свои особенности и преимущества, поэтому выбор конкретного метода зависит от 
требований вашего приложения и контекста применения. Также важно учитывать требования к производительности, удобству 
использования и возможности многократного использования кода.
Минусы потоков
К текущему моменту мы рассмотрели достоинства потоков, как они помогают увеличить скорость работы приложения, а также 
различные варианты их создания в Java. Все было бы хорошо, но использование потоков также может привести к проблемам. 
Главной из них является физическое ограничение на уровне железа, которую стоит упомянуть при обсуждении использования потоков. 
Несмотря на то, что эта проблема не связана напрямую с языком программирования, но она имеет прямое отношение к результату 
использования многопоточности. Когда его использует приложение, оно может активно подключать ресурсы процессора, 
что наверняка приведет к проблемам в случае недостатка вычислительной мощности (например, при Starvation, когда потоку 
не хватает ресурсов для работы). Физический процессор имеет ограничения по количеству потоков, которые он может 
обрабатывать одновременно. Если их число в приложении превышает допустимый предел, то могут возникнуть проблемы с 
производительностью из-за конкуренции за ресурсы процессора. Помимо этого есть и другие общеизвестные ситуации, 
которых хотелось бы избежать. Ознакомимся с ними поближе.

Состояние гонки (Race Condition)
Состояние гонки возникает, когда два или более потока пытаются одновременно получить доступ или изменить общие данные, 
и результат зависит от того, какой поток завершит свою операцию быстрее. Проблема состоит в том, что порядок 
выполнения этих операций не определен и результат может быть непредсказуемым.

 
