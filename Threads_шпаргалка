Источники https://habr.com/ru/companies/simbirsoft/articles/812097/


Процесс — это экземпляр выполняющейся программы. Каждый процесс обладает своим собственным адресным пространством и ресурсами, 
такими как файлы и сетевые соединения. По сути это изолированный контейнер, в котором выполняется код программы.

Поток (или поток выполнения) — более легковесная единица выполнения, существующая внутри процесса. В одном процессе может существовать
 несколько потоков, которые могут параллельно выполнять инструкции программы. В отличие от процессов, потоки внутри одного процесса совместно используют его ресурсы.

 Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и 
 проблем, связанных с одновременным доступом к общим ресурсам.

Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. 
Только один поток может находиться в мониторе объекта в любой момент времени.
 Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.

Критическая секция — участок кода, в котором выполняются операции над общими ресурсами. Внутри критической секции поток захватывает 
монитор объекта, чтобы гарантировать взаимное исключение.

Synchronized — это ключевое слово в Java, которое используется для синхронизации потоков. Когда метод или блок кода помечается как 
synchronized, это означает, что только один поток может выполнять данный метод или блок кода на объекте в определенный момент времени.

Volatile – это ключевое слово, использующееся для переменных в Java. Когда переменная объявлена как volatile, это гарантирует, 
что операции чтения и записи к этой переменной выполняются атомарно (в одну операцию), и также гарантирует, что изменения переменной видны всем потокам.

Например: private volatile boolean flag = false;

Если один поток изменяет значение flag, это изменение сразу же становится видимым другим потокам. Без ключевого слова volatile, 
изменения могли бы задерживаться из-за кэширования переменных потоками.

Жизненный цикл потоков в Java
1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
     необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
    Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
    В этот момент код, содержащийся в методе run(), начинает выполняться.

4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
    ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
    Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
    После завершения выполнения поток больше не может быть запущен.

Виды потоков
1. Демон-потоки  - Демон-потоки работают в фоновом режиме и предназначены для выполнения служебных задач, 
    не являющихся критически важными для основной логики программы. Когда все не-демон-потоки завершают свою работу, 
    JVM автоматически завершает выполнение программы, независимо от того, завершились демон-потоки или нет.

2. Не-демон-потоки   -  Не-демон-потоки считаются основными потоками выполнения. Если есть хотя бы один не-демон-поток, 
    JVM будет ждать завершения всех не-демон-потоков перед завершением выполнения программы.

3. Виртуальные потоки  - Начиная с 16-й версии в Java появились виртуальные потоки. Давайте сравним их с традиционными:
    Виртуальные потоки являются более легковесными, потому что они не привязаны к нативным потокам ОС, 
    в то время как обычные потоки тяжеловесные, потому что каждый обычный поток соответствует нативному потоку внутри процесса.

Способы создания и запуса потоков
1. Класс Thread  Класс java.lang.Thread в Java представляет собой API для работы с потоками, управляемыми Java Virtual Machine (JVM) и операционной системой. 
    Важно понимать, что сами экземпляры класса Thread не являются фактическими потоками, а скорее предоставляют интерфейс для управления потоками.
2. Интерфейс Runnable  -Второй способ создания потока — имплементирование интерфейса Runnable.
    Этот метод имеет ряд преимуществ по сравнению с созданием потока через Thread:
    - Гибкость в наследовании
    - Легкая реорганизация кода
    - Разделение задач
    - Повышение многократного использования
    - не предоставляет способа возвращать результат выполнения задачи.
    - Runnable не бросает проверяемые исключения (за исключением тех, которые являются подклассами RuntimeException).
3. Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
    но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
    - Callable предоставляет возможность возвращать результат выполнения задачи.
    - Callable позволяет бросать проверяемые исключения.
4. Executors - В Java пакет java.util.concurrent имеется удобный способ управления потоками через интерфейсы Executor, 
    ExecutorService и фабрику Executors. Давайте рассмотрим их основные концепции и методы создания потоков:
    - Executor. Это простой интерфейс с единственным методом execute (Runnable command). Он предназначен для выполнения 
        переданного объекта Runnable, но не предоставляет методов для управления и контроля выполнения задач.
    - ExecutorService. Это многофункциональный интерфейс, расширяющий Executor. Предоставляет более продвинутый способ 
        управления выполнением задач и включает методы управления жизненным циклом потока. Некоторые из основных методов ExecutorService
    - Executors. Это фабрика для создания различных типов исполнителей (Executor и ExecutorService), 
        где есть методы для создания исполнителей с различными характеристиками.
5. ForkJoinPool - Это особый тип пула потоков в Java, предназначенный для выполнения рекурсивных задач и разбивающий их на более мелкие.
 Он введен в Java 7 и базируется на идее «разделяй и властвуй» (divide and conquer). ForkJoinPool используется в сочетании 
 с фреймворком Fork/Join (java.util.concurrent.ForkJoinTask и java.util.concurrent.RecursiveTask).
Основные концепции ForkJoinPool:
- Разделение (Forking). Задача разбивается на более мелкие подзадачи.
- Выполнение (Joining). Подзадачи выполняются параллельно в пуле потоков и их результаты объединяются в результат исходной задачи.
6. Parallel Stream
Parallel Stream это один из механизмов параллельной обработки данных в Java, введенный в Java 8 вместе с функциональным интерфейсом java.util.stream.Stream.
7. Atomic - пакет java.util.concurrent.atomic.В многопоточной программе атомарность гарантирует, 
    что выполнение определенной операции будет происходить как единое, неделимое действие. 
8. RxJava  - RxJava – библиотека для композиции асинхронных и событийно-ориентированных программ, основанная на концепциях реактивного программирования. 
    Это набор инструментов и типов данных для работы с потоками данных и событиями. В некотором смысле RxJava напоминает асинхронную версию Stream API. 
    Оба API дают возможность работать с последовательностями данных (или потоками данных), применять операции к этим данным и выполнять их.

    Рекомендации по выбору способа создания потоков
Thread:
Вы можете использовать класс Thread, когда требуется базовая функциональность создания потока и нет необходимости в дополнительных возможностях управления и синхронизации.
ForkJoinPool:
Для параллельного выполнения независимых подзадач и управления пулом потоков, рекомендуется использовать ForkJoinPool. 
Он особенно полезен для высокоуровневого параллельного программирования.
Runnable:
Используйте интерфейс Runnable для создания потоков, если необходимо выполнить асинхронную задачу без возвращаемого значения. 
Этот подход обеспечивает многократное использование кода и отделение логики потока от его управления.
ParallelStream:
При обработке больших объемов данных и выполнении операций над ними, рассмотрите параллельные потоки данных (ParallelStream). 
Они автоматически распределят выполнение операций между доступными потоками и ускорят обработку данных.
Callable:
Если нужно получить результат выполнения задачи или обработать исключение, выбирайте интерфейс Callable. Он позволяет вернуть 
значение из потока и бросить исключение в основной поток.
Atomic:
Для обеспечения безопасности доступа к общим ресурсам из нескольких потоков хорошо подходят классы из пакета 
java.util.concurrent.atomic: AtomicInteger, AtomicLong и другие.
Executors:
Для формирования пула потоков лучше всего подходит Executors, который предоставляет удобные методы для создания и управления потоками в приложении, 
что позволит избежать этого вручную.
RxJava:
Если нужна реализация реактивного программирования и работы с асинхронными потоками, выбирайте RxJava.
 Этот подход предоставляет мощные инструменты для работы с потоками и обработки асинхронных событий.
Каждый из вышеперечисленных подходов имеет свои особенности и преимущества, поэтому выбор конкретного метода зависит от 
требований вашего приложения и контекста применения. Также важно учитывать требования к производительности, удобству 
использования и возможности многократного использования кода.
Минусы потоков
К текущему моменту мы рассмотрели достоинства потоков, как они помогают увеличить скорость работы приложения, а также 
различные варианты их создания в Java. Все было бы хорошо, но использование потоков также может привести к проблемам. Главной из них является физическое ограничение на уровне железа, которую стоит упомянуть при обсуждении использования потоков. Несмотря на то, что эта проблема не связана напрямую с языком программирования, но она имеет прямое отношение к результату использования многопоточности. Когда его использует приложение, оно может активно подключать ресурсы процессора, что наверняка приведет к проблемам в случае недостатка вычислительной мощности (например, при Starvation, когда потоку не хватает ресурсов для работы). Физический процессор имеет ограничения по количеству потоков, которые он может обрабатывать одновременно. Если их число в приложении превышает допустимый предел, то могут возникнуть проблемы с производительностью из-за конкуренции за ресурсы процессора. Помимо этого есть и другие общеизвестные ситуации, которых хотелось бы избежать. Ознакомимся с ними поближе.

Состояние гонки (Race Condition)
Состояние гонки возникает, когда два или более потока пытаются одновременно получить доступ или изменить общие данные, 
и результат зависит от того, какой поток завершит свою операцию быстрее. Проблема состоит в том, что порядок выполнения этих операций не определен и результат может быть непредсказуемым.