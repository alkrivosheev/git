Источники https://habr.com/ru/companies/simbirsoft/articles/812097/
https://habr.com/ru/companies/piter/articles/451322/

1. Чем отличается процесс от потока?
1. Чем отличается процесс от потока?
Процесс — это экземпляр выполняющейся программы. Каждый процесс обладает своим собственным адресным пространством и ресурсами, 
такими как файлы и сетевые соединения. По сути это изолированный контейнер, в котором выполняется код программы.

Поток (или поток выполнения) — более легковесная единица выполнения, существующая внутри процесса. В одном процессе может существовать
 несколько потоков, которые могут параллельно выполнять инструкции программы. В отличие от процессов, потоки внутри одного процесса совместно используют его ресурсы.

2. Каким образом можно создать поток?
	Способы создания и запуса потоков
	1. Когда вы наследуете от класса Thread, вы создаете новый класс, который переопределяет метод run(). 
		Затем вы создаете экземпляр этого класса и вызываете метод start() для запуска потока.
			class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
				}
			}
	2. Интерфейс Runnable  -Второй способ создания потока — имплементирование интерфейса Runnable.
		class MyRunnable implements Runnable {
			@Override
			public void run() {
				System.out.println("Поток выполняется через Runnable");
			}
		}

		public class Main {
			public static void main(String[] args) {
				MyRunnable myRunnable = new MyRunnable();
				Thread thread = new Thread(myRunnable);
				thread.start();
			}
		}
		Этот метод имеет ряд преимуществ по сравнению с созданием потока через Thread:
		- Гибкость в наследовании
		- Легкая реорганизация кода
		- Разделение задач
		- Повышение многократного использования
		- не предоставляет способа возвращать результат выполнения задачи.
		- Runnable не бросает проверяемые исключения (за исключением тех, которые являются подклассами RuntimeException).
	3. Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
	 Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и 
	 проблем, связанных с одновременным доступом к общим ресурсам.
	 
	Состояния потоков
	Потоки могут пребывать в нескольких состояниях:
	New – когда создается экземпляр класса Thread, поток находится в состоянии new. Он пока еще не работает.
	Running — поток запущен и процессор начинает его выполнение. Во время выполнения состояние потока также может измениться на Runnable, Dead или Blocked.
	Suspended — запущенный поток приостанавливает свою работу, затем можно возобновить его выполнение. Поток начнет работать с того места, где его остановили.
	Blocked — поток ожидает высвобождения ресурсов или завершение операции ввода-вывода. Находясь в этом состоянии поток не потребляет процессорное время.
	Terminated — поток немедленно завершает свое выполнение. Его работу нельзя возобновить. Причинами завершения потока могут быть ситуации, когда код потока 
		полностью выполнен или во время выполнения потока произошла ошибка (например, ошибка сегментации или необработанного исключения).
	Dead — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл.

	Жизненный цикл потоков в Java
	1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
		 необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

	2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
		Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

	3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
		В этот момент код, содержащийся в методе run(), начинает выполняться.

	4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
		ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

	5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
		Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
		После завершения выполнения поток больше не может быть запущен.

3. Как работают методы sleep, yield, wait, notify и notifyAll?
	В Java методы sleep, yield, wait, notify и notifyAll используются для управления потоками (threads) и их синхронизацией. 
	Каждый из этих методов выполняет определенную задачу, связанную с управлением выполнением потоков.
	sleep: Для приостановки потока на определенное время.
	yield: Для уступки процессорного времени другим потокам.
	wait, notify, notifyAll: Для синхронизации потоков и управления доступом к общим ресурсам.


	Сравнение методов:
	Метод	Состояние потока	Освобождает монитор	Вызывается в synchronized	Прерываемый
	sleep()	TIMED_WAITING		Нет					Нет							Да
	yield()	RUNNABLE			Нет					Нет							Нет
	wait()	WAITING				Да					Да							Да
	notify()	-				Нет					Да							Нет
	notifyAll()	-				Нет					Да							Нет
	
	Метод sleep приостанавливает выполнение текущего потока на указанное количество миллисекунд. 
		Поток переходит в состояние TIMED_WAITING, но при этом не освобождает монитор (если он был захвачен).
	Метод yield предлагает планировщику потоков (thread scheduler) переключиться на другой поток, который готов к выполнению. 
		Это способ "уступить" процессорное время другим потокам.
	Метод wait используется для приостановки текущего потока до тех пор, пока другой поток не вызовет notify() или notifyAll() для того же объекта. 
		Поток переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания).
	Метод notify пробуждает один поток, который находится в состоянии ожидания (вызвав wait() на том же объекте). 
		Если несколько потоков ожидают, то выбор конкретного потока зависит от планировщика.
	Метод notifyAll пробуждает все потоки, которые находятся в состоянии ожидания (вызвав wait() на том же объекте). 
		После этого все потоки начнут конкурировать за монитор.

4. Объясните следующие термины: монитор, мьютекс, критическая секция.
	Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. 
		Только один поток может находиться в мониторе объекта в любой момент времени.
		Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.
2. Каким образом можно создать поток?
	Способы создания и запуса потоков
	1. Когда вы наследуете от класса Thread, вы создаете новый класс, который переопределяет метод run(). 
		Затем вы создаете экземпляр этого класса и вызываете метод start() для запуска потока.
			class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
				}
			}
	2. Интерфейс Runnable  -Второй способ создания потока — имплементирование интерфейса Runnable.
		class MyRunnable implements Runnable {
			@Override
			public void run() {
				System.out.println("Поток выполняется через Runnable");
			}
		}

		public class Main {
			public static void main(String[] args) {
				MyRunnable myRunnable = new MyRunnable();
				Thread thread = new Thread(myRunnable);
				thread.start();
			}
		}
		Этот метод имеет ряд преимуществ по сравнению с созданием потока через Thread:
		- Гибкость в наследовании
		- Легкая реорганизация кода
		- Разделение задач
		- Повышение многократного использования
		- не предоставляет способа возвращать результат выполнения задачи.
		- Runnable не бросает проверяемые исключения (за исключением тех, которые являются подклассами RuntimeException).
	3. Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
	 Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и 
	 проблем, связанных с одновременным доступом к общим ресурсам.
	 
	Состояния потоков
	Потоки могут пребывать в нескольких состояниях:
	New – когда создается экземпляр класса Thread, поток находится в состоянии new. Он пока еще не работает.
	Running — поток запущен и процессор начинает его выполнение. Во время выполнения состояние потока также может измениться на Runnable, Dead или Blocked.
	Suspended — запущенный поток приостанавливает свою работу, затем можно возобновить его выполнение. Поток начнет работать с того места, где его остановили.
	Blocked — поток ожидает высвобождения ресурсов или завершение операции ввода-вывода. Находясь в этом состоянии поток не потребляет процессорное время.
	Terminated — поток немедленно завершает свое выполнение. Его работу нельзя возобновить. Причинами завершения потока могут быть ситуации, когда код потока 
		полностью выполнен или во время выполнения потока произошла ошибка (например, ошибка сегментации или необработанного исключения).
	Dead — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл.

	Жизненный цикл потоков в Java
	1. Создание (New) -На этой стадии поток только что был создан, но еще не запущен. Чтобы его создать,
		 необходимо сформировать объект класса Thread и, при необходимости, передать ему объект, реализующий интерфейс Runnable.

	2. Готовность (Runnable) - Поток переходит в состояние готовности, когда вызывается метод start(). 
		Но его финальную готовность определяет система планирования операционной системы — она решает, когда поток будет выделен для выполнения.

	3. Выполнение (Running) -Когда поток получает выделение от планировщика операционной системы, он переходит в состояние выполнения. 
		В этот момент код, содержащийся в методе run(), начинает выполняться.

	4. Ожидание (Blocked/Waiting) - Поток может временно оказаться в состоянии ожидания по различным причинам, например, 
		ожидание блокировки (Blocked) или ожидание события (Waiting). Это происходит, когда поток ожидает выполнения какого-то условия или ресурса.

	5. Завершение (Terminated) - Когда выполнение метода run() завершается, поток переходит в состояние завершения. 
		Это может произойти при естественном завершении выполнения кода или в случае вызова метода stop(). 
		После завершения выполнения поток больше не может быть запущен.

3. Как работают методы sleep, yield, wait, notify и notifyAll?
	В Java методы sleep, yield, wait, notify и notifyAll используются для управления потоками (threads) и их синхронизацией. 
	Каждый из этих методов выполняет определенную задачу, связанную с управлением выполнением потоков.
	sleep: Для приостановки потока на определенное время.
	yield: Для уступки процессорного времени другим потокам.
	wait, notify, notifyAll: Для синхронизации потоков и управления доступом к общим ресурсам.


	Сравнение методов:
	Метод	Состояние потока	Освобождает монитор	Вызывается в synchronized	Прерываемый
	sleep()	TIMED_WAITING		Нет					Нет							Да
	yield()	RUNNABLE			Нет					Нет							Нет
	wait()	WAITING				Да					Да							Да
	notify()	-				Нет					Да							Нет
	notifyAll()	-				Нет					Да							Нет
	
	Метод sleep приостанавливает выполнение текущего потока на указанное количество миллисекунд. 
		Поток переходит в состояние TIMED_WAITING, но при этом не освобождает монитор (если он был захвачен).
	Метод yield предлагает планировщику потоков (thread scheduler) переключиться на другой поток, который готов к выполнению. 
		Это способ "уступить" процессорное время другим потокам.
	Метод wait используется для приостановки текущего потока до тех пор, пока другой поток не вызовет notify() или notifyAll() для того же объекта. 
		Поток переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания).
	Метод notify пробуждает один поток, который находится в состоянии ожидания (вызвав wait() на том же объекте). 
		Если несколько потоков ожидают, то выбор конкретного потока зависит от планировщика.
	Метод notifyAll пробуждает все потоки, которые находятся в состоянии ожидания (вызвав wait() на том же объекте). 
		После этого все потоки начнут конкурировать за монитор.

4. Объясните следующие термины: монитор, мьютекс, критическая секция.
	Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. 
		Только один поток может находиться в мониторе объекта в любой момент времени.
		Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.

	Критическая секция — участок кода, в котором выполняются операции над общими ресурсами. Внутри критической секции поток захватывает 
		монитор объекта, чтобы гарантировать взаимное исключение.
		
5. Как работает join()?
	Метод join() — это удобный способ синхронизации потоков, позволяющий одному потоку дождаться завершения другого. 
		Он особенно полезен в сценариях, где порядок выполнения потоков имеет значение.
	Метод join() в Java используется для того, чтобы один поток мог дождаться завершения выполнения другого потока. Когда поток вызывает join() для другого потока, 
		он переходит в состояние WAITING или TIMED_WAITING (если указано время ожидания) и ждет, пока целевой поток завершит свою работу.
		class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("Поток выполняется через Thread");
				}
			}

			public class Main {
				public static void main(String[] args) {
					MyThread myThread = new MyThread();
					myThread.start();
					// Основной поток ждет завершения потока myThread
					myThread.join();
				}
			}
			
6. Что такое DeadLock? Приведите примеры.
	Взаимоблокировка (Deadlock) Взаимоблокировка возникает, когда два или более потока удерживают ресурсы и ждут друг друга для освобождения ресурсов, 
		необходимых другим потокам. Как результат – ни один из потоков не может продолжить выполнение и программа оказывается заблокированной.
		
		Для возникновения взаимной блокировки необходимо выполнение следующих четырех условий (условия Коффмана):
		-Взаимное исключение (Mutual Exclusion):
			Ресурсы, которые используют потоки, не могут быть разделены между ними. Только один поток может владеть ресурсом в любой момент времени.
		-Удержание и ожидание (Hold and Wait):
			Поток удерживает один ресурс и одновременно ожидает освобождения другого ресурса, захваченного другим потоком.
		-Отсутствие вытеснения (No Preemption):
			Ресурсы нельзя отобрать у потока. Только поток, владеющий ресурсом, может его освободить.
		-Круговая зависимость (Circular Wait):
			Потоки образуют замкнутый круг, где каждый поток ожидает ресурс, удерживаемый следующим потоком в цепи.
			
		Как избежать Deadlock:
		-Упорядоченное захватывание ресурсов:
			Всегда захватывайте ресурсы в одном и том же порядке. Например, в примере выше можно захватывать сначала resource1, а затем resource2 в обоих потоках.
		-Использование тайм-аутов:
			Используйте методы с тайм-аутом, такие как tryLock() из java.util.concurrent.locks.ReentrantLock, чтобы избежать бесконечного ожидания.
		-Разрушение условий Deadlock:
			Нарушьте одно из условий Коффмана. Например, можно использовать вытеснение ресурсов или избегать удержания ресурсов при ожидании других.
		-Использование высокоуровневых инструментов:
			Используйте библиотеки и инструменты для работы с многопоточностью, такие как java.util.concurrent, которые помогают избегать Deadlock.
			

7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
	В Java для работы с потоко-безопасными (thread-safe) ассоциативными массивами (map) можно использовать два основных подхода: Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap. 
		Оба подхода обеспечивают потокобезопасность, но делают это по-разному, что влияет на их производительность и поведение. Рассмотрим их различия.
			1. Collections.synchronizedMap(new HashMap())
				Этот метод создает синхронизированную обертку вокруг обычного HashMap. 
					Вся работа с картой синхронизируется на уровне метода, что делает ее потокобезопасной.
				Синхронизация:
				Каждый метод карты (например, put, get, remove) синхронизирован на уровне объекта-обертки.
				Это означает, что только один поток может выполнять операции с картой в любой момент времени.
				Пример:
					Map<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
				Преимущества:
					Простота использования.
					Гарантирует потокобезопасность для всех операций.
				Недостатки:
					Низкая производительность при высокой конкуренции, так как все операции блокируют всю карту.
					Нет поддержки атомарных операций (например, putIfAbsent).
			2. ConcurrentHashMap — это специализированная потокобезопасная реализация интерфейса Map, которая использует более сложный механизм синхронизации для повышения производительности.
				Синхронизация:
				Внутренняя структура ConcurrentHashMap разделена на сегменты (в более старых версиях) 
					или использует CAS (Compare-And-Swap) операции и блокировки на уровне отдельных ячеек (в новых версиях).
				Это позволяет нескольким потокам одновременно читать и даже изменять карту, если они работают с разными сегментами или ячейками.
				Пример:
					Map<String, String> concurrentHashMap = new ConcurrentHashMap<>();
				Преимущества:
					Высокая производительность при высокой конкуренции, так как блокировки применяются только к отдельным сегментам или ячейкам.
					Поддержка атомарных операций, таких как putIfAbsent, compute, merge и других.
					Не блокирует всю карту при выполнении операций.
				Недостатки:
					Более сложная реализация.
					Нет гарантии строгой консистентности (например, при итерации карты могут быть видны частично выполненные изменения).
					
8. Различия в интерфейсах Runnable и Callable.
	Интерфейс Callable - интерфейсы Callable и Runnable используются для выполнения кода в отдельном потоке, 
		но есть различия в том, как они предоставляют результат выполнения и обрабатывают исключения.
		- Callable предоставляет возможность возвращать результат выполнения задачи.
		- Callable позволяет бросать проверяемые исключения.
		Runnable — это простой интерфейс для задач, которые не возвращают результат и не выбрасывают проверяемые исключения.
		Callable — это более мощный интерфейс, который позволяет возвращать результат и выбрасывать исключения.
			Он используется вместе с ExecutorService и Future для управления выполнением задач и получения результатов.
			
9. Различия между isInterrupted(), interrupted(), interrupt().
	В Java методы isInterrupted(), interrupted() и interrupt() связаны с управлением состоянием прерывания потока. Они используются для проверки и изменения состояния флага прерывания потока.
		Однако между ними есть важные различия, которые важно понимать для корректной работы с многопоточностью.
		1. interrupt()используется для установки флага прерывания потока. Если поток находится в состоянии ожидания 
			(например, вызвал sleep(), wait(), join()), то вызов interrupt() выбросит исключение InterruptedException.
		2. isInterrupted() проверяет, был ли установлен флаг прерывания для потока. Этот метод не сбрасывает флаг прерывания.
		3. interrupted() — это статический метод класса Thread, который проверяет, был ли установлен флаг прерывания для текущего потока. 
			В отличие от isInterrupted(), этот метод сбрасывает флаг прерывания после проверки.
	
		Основные различия:
			Метод			Тип метода		Сбрасывает флаг прерывания	Проверяемый поток
			interrupt()		Нестатический	Нет							Любой поток
			isInterrupted()	Нестатический	Нет							Любой поток
			interrupted()	Статический		Да							Текущий поток

10. Что происходит при вызове Thread.interrupt()?
	Устанавливает флаг прерывания потока.
	Если поток находится в состоянии ожидания, выбрасывает InterruptedException.
	Не останавливает поток немедленно — поток должен сам проверить флаг прерывания и завершить выполнение.

11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.
	Вызов Thread.interrupt(): Если другой поток вызывает метод interrupt() на текущем потоке, и текущий поток находится в состоянии ожидания (например, вызван sleep(), wait(), join()), то выбрасывается InterruptedException.
	Метод Thread.sleep(): Если поток находится в состоянии сна (вызван Thread.sleep()), и в этот момент другой поток вызывает interrupt() на этом потоке, то выбрасывается InterruptedException.
	Метод Object.wait(): Если поток ожидает на мониторе объекта (вызван Object.wait()), и в этот момент другой поток вызывает interrupt() на этом потоке, то выбрасывается InterruptedException.
	Метод Thread.join(): Если поток ожидает завершения другого потока (вызван Thread.join()), и в этот момент другой поток вызывает interrupt() на этом потоке, то выбрасывается InterruptedException.
	Блокирующие операции ввода-вывода (I/O): Некоторые блокирующие операции ввода-вывода (например, чтение из сокета) могут быть прерваны, если поток, выполняющий их, будет прерван. В этом случае также может быть выброшено InterruptedException.
	Использование Future.get()

12. Назовите отличия synchronized{} и ReentrantLock.
		В Java synchronized и ReentrantLock используются для управления доступом к общим ресурсам в многопоточной среде, 
		но они имеют существенные различия в функциональности, гибкости и производительности. Вот основные отличия:
			synchronized:
				Встроен в язык Java.
				Используется с ключевым словом synchronized для блоков или методов.
				Ограничен в функциональности. Не поддерживает прерывание ожидания блокировки или тайм-ауты. Не позволяет проверять, 
				удерживается ли блокировка другим потоком.
				Пример:
					java
					Copy
					synchronized (lockObject) {
						// Критическая секция
					}
				Не требует явного освобождения блокировки — она автоматически освобождается при выходе из блока или метода.

			ReentrantLock:
				Реализован в классе java.util.concurrent.locks.ReentrantLock.
				Требует явного создания объекта ReentrantLock и управления блокировкой.
				Более гибкий. Поддерживает прерывание ожидания блокировки с помощью lockInterruptibly(). 
				Позволяет задавать тайм-ауты при попытке захвата блокировки с помощью tryLock(long timeout, TimeUnit unit).
				Позволяет проверять, удерживается ли блокировка с помощью isLocked(). Поддерживает честную блокировку (fair lock), 
				где потоки получают блокировку в порядке очереди.
				Пример:
					java
					Copy
					ReentrantLock lock = new ReentrantLock();
					lock.lock();
					try {
						// Критическая секция
					} finally {
						lock.unlock(); // Обязательно освобождать блокировку в finally
					}
				Требует явного вызова unlock() для освобождения блокировки.

13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.
		Основное отличие между CountDownLatch и CyclicBarrier заключается в их предназначении и поведении:
		CountDownLatch:
			Используется для ожидания завершения одного или нескольких потоков.
			Потоки, вызывающие await(), будут заблокированы до тех пор, пока счетчик не станет равным нулю.
			Счетчик уменьшается с помощью метода countDown().
			CountDownLatch является одноразовым: после того как счетчик достигнет нуля, его нельзя переинициализировать или использовать повторно.
		CyclicBarrier:
			Используется для синхронизации группы потоков, которые должны дождаться друг друга в определенной точке выполнения.
			Потоки, вызывающие await(), будут заблокированы до тех пор, пока все потоки не достигнут барьера.
			После того как все потоки достигнут барьера, они продолжают выполнение.
			CyclicBarrier может быть повторно использован: после того как все потоки достигнут барьера, он может быть сброшен и использован снова.

14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.
	Основное отличие между CyclicBarrier и Phaser заключается в их гибкости и функциональности:
	CyclicBarrier:
		Используется для синхронизации фиксированного числа потоков, которые должны дождаться друг друга в определенной точке выполнения.
		Все потоки должны вызвать await(), чтобы достичь барьера, и после того как все потоки достигнут барьера, они продолжают выполнение.
		CyclicBarrier может быть повторно использован после того, как все потоки достигнут барьера, но число потоков остается фиксированным.
	Phaser:
		Более гибкий механизм синхронизации, который позволяет динамически изменять количество потоков, участвующих в синхронизации.
		Потоки могут регистрироваться и отменять регистрацию динамически с помощью методов register() и arriveAndDeregister().
		Phaser поддерживает несколько фаз синхронизации, и потоки могут синхронизироваться на каждой фазе.
		Phaser может быть использован для более сложных сценариев синхронизации, где количество потоков может изменяться во времени.
	Таким образом, CyclicBarrier подходит для сценариев с фиксированным числом потоков, 
	тогда как Phaser предоставляет большую гибкость для динамических и сложных сценариев синхронизации.

15. Расскажите про Exchanger.
	Exchanger — это класс из пакета java.util.concurrent, который используется для обмена данными между двумя потоками.
	Он предоставляет простой способ синхронизации и обмена данными между двумя потоками, обеспечивая, что обмен происходит только тогда, когда оба потока готовы.
	Exchanger полезен в сценариях, где два потока должны синхронизироваться и обмениваться данными. Например, это может быть полезно в алгоритмах, 
	где один поток производит данные, а другой их потребляет (Producer-Consumer) и оба должны синхронизироваться для обмена результатами.

16. Отличие Thread.start() и Thread.run()?
Отличие между методами Thread.start() и Thread.run() в Java заключается в том, как они запускают выполнение потока:
Thread.start():
	Этот метод используется для запуска нового потока.
	Когда вы вызываете start(), создается новый поток выполнения, и метод run() вызывается в этом новом потоке.
	Это означает, что код в методе run() будет выполняться параллельно с кодом, который следует после вызова start().
Thread.run():
	Этот метод вызывает метод run() в текущем потоке, а не в новом.
	Когда вы вызываете run() напрямую, код в методе run() выполняется последовательно в том же потоке, в котором был вызван run().
	Это не создает новый поток выполнения.

17. Объясните ключевое слово volatile.
	Ключевое слово volatile в Java используется для обозначения переменной, значение которой может быть изменено несколькими потоками. 
	Оно гарантирует, что чтение и запись этой переменной будут происходить непосредственно в основной памяти, а не в кэше потока. 
	Это обеспечивает видимость изменений, внесенных одним потоком, для всех других потоков

18. Расскажите про приоритеты потока
	Приоритеты потоков в Java используются для управления порядком выполнения потоков. Приоритет потока определяет, 
	насколько важен этот поток по сравнению с другими потоками. Java предоставляет механизм для задания приоритетов потокам, 
	что позволяет планировщику потоков (thread scheduler) учитывать эти приоритеты при распределении процессорного времени.

19. Что такое потоки-демоны?
	Потоки-демоны (daemon threads) в Java — это потоки, которые выполняются в фоновом режиме и не препятствуют завершению программы. 
	В отличие от обычных (пользовательских) потоков, потоки-демоны не мешают виртуальной машине Java (JVM) завершить выполнение, 
	когда все пользовательские потоки завершены.

20. Назовите все возможные состояния потока
	В Java поток может находиться в одном из нескольких состояний, которые описывают его жизненный цикл. Вот основные состояния потока:
		New (Новый): Поток создан, но еще не запущен. В этом состоянии поток существует, но метод start() еще не был вызван.
		Runnable (Выполняемый): Поток запущен и ожидает выполнения. Это состояние включает как фактическое выполнение потока, так и ожидание процессорного времени для выполнения.
		Blocked (Заблокированный): Поток заблокирован и ожидает монитора (блокировки), чтобы войти в синхронизированный блок или метод. Поток находится в этом состоянии, когда он пытается получить доступ к ресурсу, который уже занят другим потоком.
		Waiting (Ожидающий): Поток ожидает бесконечно долго, пока не будет уведомлен другим потоком. Это состояние возникает, когда поток вызывает методы Object.wait(), Thread.join() или LockSupport.park() без указания времени ожидания.
		Timed Waiting (Ожидающий с тайм-аутом): Поток ожидает в течение указанного времени. Это состояние возникает, когда поток вызывает методы Thread.sleep(long millis), Object.wait(long timeout), Thread.join(long millis), LockSupport.parkNanos(long nanos) или LockSupport.parkUntil(long deadline) с указанием времени ожидания.
		Terminated (Завершенный): Поток завершил выполнение. Это состояние возникает, когда метод run() завершил выполнение, либо поток был прерван.

21. Что такое race condition?
	Race condition (состояние гонки) — это ситуация в многопоточных или параллельных программах, 
	когда результат выполнения программы зависит от последовательности или времени выполнения потоков или процессов. Это происходит, 
	когда несколько потоков или процессов одновременно пытаются изменить общие данные, что может привести к некорректным или непредсказуемым результатам.
	Причины возникновения race condition:
		Одновременный доступ к общим ресурсам
		Отсутствие синхронизации

22. Что такое Thread Local переменная? 
	Thread Local переменная (локальная переменная потока) — это переменная, которая уникальна для каждого потока. 
	Это означает, что каждый поток имеет свою собственную копию этой переменной, и изменения, внесенные одним потоком,
	не видны другим потокам. Thread Local переменные полезны для хранения данных, 
	которые должны быть уникальными для каждого потока, таких как идентификаторы транзакций, соединения с базой данных и другие контекстные данные.

23. Что такое FutureTask?
	FutureTask — это класс из пакета java.util.concurrent, который представляет собой асинхронную задачу, 
	результат выполнения которой можно получить в будущем. FutureTask реализует интерфейсы Future и Runnable, 
	что позволяет использовать его как задачу для выполнения в потоке или пуле потоков, а также для получения результата выполнения.
	Основные характеристики FutureTask:
		Асинхронное выполнение, Получение результата, Отмена задачи, Проверка завершения:

24. Что такое Thread Pool?
	Thread Pool (пул потоков) — это коллекция предварительно созданных потоков, которые могут быть повторно использованы для выполнения задач. 
	Пул потоков позволяет эффективно управлять потоками, уменьшая накладные расходы на создание и уничтожение потоков, 
	а также оптимизируя использование ресурсов системы.
	Основные характеристики Thread Pool:
		Повторное использование потоков:
			Потоки в пуле могут быть повторно использованы для выполнения различных задач, что уменьшает накладные расходы на создание и уничтожение потоков.
		Ограничение количества потоков:
			Пул потоков позволяет ограничить количество одновременно выполняющихся потоков, что помогает предотвратить перегрузку системы и эффективно использовать ресурсы.
		Управление задачами:
			Задачи могут быть отправлены в пул потоков для выполнения. Пул потоков управляет очередью задач и распределяет их между доступными потоками.
		Использование ExecutorService:
			В Java для работы с пулами потоков используется интерфейс ExecutorService, который предоставляет методы для управления задачами и потоками.

25. Что такое Semaphore?
	Semaphore — это класс из пакета java.util.concurrent, который используется для управления доступом к ограниченным 
	ресурсам в многопоточных приложениях. Семафор действует как счетчик, который контролирует количество потоков,
	которые могут одновременно получить доступ к ресурсу.
	Основные характеристики Semaphore:
		Счетчик разрешений:
			Семафор имеет счетчик разрешений, который указывает, сколько потоков могут одновременно получить доступ к ресурсу.
			Когда поток получает доступ к ресурсу, счетчик уменьшается. Когда поток освобождает ресурс, счетчик увеличивается.
		Методы acquire() и release():
			Метод acquire() используется для получения разрешения на доступ к ресурсу. Если счетчик разрешений равен нулю, поток блокируется до тех пор, пока другой поток не освободит ресурс.
			Метод release() используется для освобождения ресурса и увеличения счетчика разрешений.
		Справедливость:
			Семафор может быть создан с параметром справедливости (fairness). Если справедливость установлена в true, потоки получают доступ к ресурсу в порядке их очереди. Если справедливость установлена в false, порядок доступа не гарантируется.

26. Чем отличается submit от execute у ExecutorService?
	Методы submit и execute у ExecutorService в Java используются для отправки задач на выполнение, но они имеют разные особенности и предназначения.
	execute: Метод execute используется для отправки задачи на выполнение без возврата результата.
		Метод execute принимает объект типа Runnable. Метод execute не возвращает никакого значения. Он просто отправляет задачу на выполнение.
	submit: используется для отправки задачи на выполнение и возврата объекта Future, который представляет результат выполнения задачи.
		Метод submit может принимать объекты типа Runnable или Callable. Метод submit возвращает объект Future, 
		который можно использовать для получения результата выполнения задачи или для проверки статуса выполнения.


27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
	Методы shutdown и shutdownNow у ThreadPoolExecutor (или ExecutorService) в Java используются для завершения работы пула потоков, 
	но они имеют разные особенности и предназначения.
		shutdown:инициирует порядок завершения пула потоков. После вызова этого метода пул потоков перестает принимать новые задачи, 
			но продолжает выполнять уже отправленные задачи. Новые задачи, 
			отправленные после вызова shutdown, будут отклонены с помощью политики отклонения задач (RejectedExecutionHandler).
		shutdownNow: инициирует немедленное завершение работы пула потоков. Он пытается остановить все активные задачи и возвращает список задач,
			которые не были выполнены. Пул потоков пытается прервать все активные задачи, вызывая метод Thread.interrupt() для каждого потока.


28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
	Для создания пула потоков с использованием ExecutorService в Java можно использовать методы из класса Executors.
	1 поток:
		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
	5 потоков:
		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
	Пул потоков с кэшированным количеством потоков (неограниченное количество потоков):
		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();

29. Что такое ReadWriteLock?
	ReadWriteLock — это интерфейс из пакета java.util.concurrent.locks, который предоставляет механизм для управления доступом к ресурсам, 
	поддерживающим как чтение, так и запись. ReadWriteLock позволяет различать блокировки для чтения и записи, 
	что может значительно повысить производительность в многопоточных приложениях, где операции чтения происходят чаще, чем операции записи.
	Основные характеристики ReadWriteLock:
		Разделение блокировок: ReadWriteLock предоставляет два типа блокировок: блокировку для чтения (read lock) и блокировку для записи (write lock).
			Блокировка для чтения позволяет нескольким потокам одновременно читать ресурс, если нет активной блокировки для записи.
			Блокировка для записи позволяет только одному потоку записывать ресурс, блокируя все остальные потоки, как для чтения, так и для записи.
		Методы lock() и unlock(): используются для установки и снятия блокировок для чтения и записи.
			Блокировка для чтения устанавливается с помощью метода readLock().lock(), а снимается с помощью метода readLock().unlock().
			Блокировка для записи устанавливается с помощью метода writeLock().lock(), а снимается с помощью метода writeLock().unlock().
		Реализация ReentrantReadWriteLock: является стандартной реализацией интерфейса ReadWriteLock. Он предоставляет механизм для 
			управления блокировками для чтения и записи с поддержкой реентерабельности (возможности повторного входа).

30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().
		Thread: представляет собой поток выполнения в Java. Он используется для создания и управления потоками, которые выполняют задачи параллельно.
			Thread является низкоуровневым механизмом для управления потоками и предоставляет базовые методы для запуска, остановки и управления потоками.
		Thread.interrupt(): используется для прерывания выполнения потока. Он устанавливает флаг прерывания для потока, который может быть проверен 
			с помощью метода isInterrupted() или interrupted().
			Прерывание потока не останавливает его выполнение напрямую, но позволяет потоку самостоятельно завершить выполнение, если он проверяет флаг прерывания.
		FutureTask: представляет собой асинхронную задачу, результат выполнения которой можно получить в будущем. 
			Он реализует интерфейсы Future и Runnable, что позволяет использовать его как задачу для выполнения в потоке или пуле потоков, 
			а также для получения результата выполнения.
			FutureTask предоставляет механизм для отмены задачи и получения результата выполнения, что делает его более высокоуровневым инструментом для
			 управления асинхронными задачами.
		FutureTask.cancel(): используется для отмены выполнения задачи. Если задача еще не началась, она будет отменена. 
			Если задача уже выполняется, попытка отмены может прервать выполнение, если mayInterruptIfRunning установлен в true.
			Отмена задачи приводит к тому, что все потоки, ожидающие завершения задачи с помощью метода get(), получат исключение CancellationException.

31. Расскажите про шаблон проектирования Producer Consumer.
	Шаблон проектирования Producer-Consumer (Продюсер-Потребитель) используется для организации взаимодействия между потоками или процессами, 
	где один или несколько потоков (продюсеров) создают данные, а один или несколько других потоков (потребителей) обрабатывают эти данные. 
	Этот шаблон помогает разделить задачи на производство и потребление данных, что улучшает модульность и управляемость кода.

32. Как можно запустить параллельный поток (parallelStream)?
	Метод parallelStream() доступен для всех коллекций, реализующих интерфейс Collection (например, List, Set).
	Этот метод возвращает параллельный поток, который автоматически использует ForkJoinPool для выполнения операций.
	Параллельные потоки используют ForkJoinPool, который по умолчанию использует все доступные ядра процессора.
	Коллекция разделяется на части, и каждая часть обрабатывается в отдельном потоке.
	Результаты обработки объединяются в конце.

33. Что делают методы parallel и sequential?
	В Java Stream API методы parallel() и sequential() используются для управления режимом выполнения потоков (streams). 
	Они определяют, будут ли операции над потоком выполняться параллельно или последовательно. Рассмотрим их подробнее.
	Метод parallel()преобразует поток в параллельный. Это означает, что операции над потоком будут выполняться одновременно в нескольких потоках (threads), 
		используя ForkJoinPool.
	Метод sequential() преобразует поток в последовательный. Это означает, что операции над потоком будут выполняться в одном потоке (последовательно).

34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.
	Параллельные потоки обрабатывают элементы коллекции одновременно в нескольких потоках, что может привести к нарушению порядка следования элементов. 
	Это происходит потому, что элементы обрабатываются независимо и могут быть завершены в произвольном порядке.
	Если порядок элементов важен, можно использовать методы, которые гарантируют сохранение порядка:
		forEachOrdered(): Этот метод выполняет действия над элементами в порядке их следования в исходной коллекции, даже в параллельном потоке.
		collect(): Методы сбора данных, такие как collect(Collectors.toList()), сохраняют порядок элементов.

35. В чем разница между методами forEach и forEachOrdered?
	Методы forEach и forEachOrdered в Java Stream API используются для выполнения действий над каждым элементом потока. 
	Однако они имеют важные различия в поведении, особенно при работе с параллельными потоками.
	Метод forEach
		Метод forEach выполняет действие для каждого элемента потока, но не гарантирует порядок выполнения, особенно в параллельных потоках.
		Особенности:
			В последовательном потоке (stream()) элементы обрабатываются в порядке их следования.
			В параллельном потоке (parallelStream()) порядок выполнения не гарантируется, так как элементы обрабатываются одновременно в нескольких потоках.
	Метод forEachOrdered
		Метод forEachOrdered выполняет действие для каждого элемента потока, гарантируя порядок выполнения, даже в параллельных потоках.
		Особенности:
			В последовательном потоке поведение аналогично forEach.
			В параллельном потоке элементы обрабатываются в порядке их следования в исходной коллекции, даже если обработка выполняется в нескольких потоках.
	Когда использовать:
		forEach:Когда порядок выполнения не важен.
			Для повышения производительности в параллельных потоках.
			Например, для выполнения независимых операций (логирование, сохранение в базу данных).
		forEachOrdered:
			Когда порядок выполнения важен.
			Например, для вывода элементов в определенном порядке или для операций, зависящих от порядка.

36. В чем разница между применением метода peek() в последовательном и параллельном потоках?
	 Метод peek() в последовательном потоке (stream()) метод peek() выполняет действия над элементами в порядке их следования в коллекции.
	 Метод peek() в параллельном потоке (parallelStream()) метод peek() может выполняться одновременно в нескольких потоках, что приводит к непредсказуемому порядку выполнения.
	Есть хороший метод forEachOrdered() который не сортирует, а именно сохраняет исходный порядок следования элементов.


37. Что делает метод unordered?
	Метод unordered() в Java Stream API используется для указания того, что порядок элементов в потоке не важен. 
	Это может повысить производительность некоторых операций, особенно в параллельных потоках, так как Stream API 
	может отказаться от поддержания порядка элементов, что снижает накладные расходы.
	Что делает unordered()?
		Снимает ограничение на порядок элементов: Поток больше не гарантирует сохранение порядка элементов, даже если исходная коллекция была упорядоченной (например, List).
		Оптимизация производительности: Некоторые операции (например, distinct(), groupingBy) могут выполняться быстрее, если порядок элементов не важен.
		Не изменяет исходную коллекцию: Метод unordered() влияет только на поведение потока, но не изменяет исходную коллекцию.

38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?
	Когда имеет смысл распараллеливать поток?
	Большие объемы данных: Параллельные потоки эффективны для обработки больших коллекций (например, десятки тысяч элементов или больше).
		Для небольших коллекций накладные расходы на создание и управление потоками могут превысить выгоду от параллельной обработки.
	Вычислительно сложные задачи: Если операции над элементами требуют значительных вычислений (например, математические расчеты, обработка изображений), 
		распараллеливание может ускорить выполнение.
	Независимые операции: Операции над элементами должны быть независимыми, то есть результат обработки одного элемента не должен зависеть от другого.
	Отсутствие блокирующих операций: Параллельные потоки не подходят для задач, связанных с блокирующими операциями (например, вводом-выводом), 
	так как это может привести к простоям потоков.

	Условия для распараллеливания:
		Потокобезопасность:	Убедитесь, что операции в параллельном потоке являются потокобезопасными. 
			Например, избегайте изменяемых состояний (mutable state) и используйте синхронизацию, если это необходимо.
		Отсутствие побочных эффектов: Операции в параллельном потоке не должны иметь побочных эффектов, которые могут привести к неопределенному поведению.
		Порядок выполнения:	Если порядок выполнения операций важен, используйте методы, которые гарантируют сохранение порядка (например, forEachOrdered).
		Качество реализации: Используйте высококачественные алгоритмы и структуры данных, которые эффективно работают в многопоточной среде.

39. Расскажите про Java NIO и её главные составляющие.
	Java NIO (New I/O) — это набор API, представленный в Java 1.4, который предоставляет более эффективные и гибкие способы работы с 
	вводом-выводом (I/O) по сравнению с классическим Java IO. Основное отличие Java NIO от Java IO заключается в поддержке неблокирующего I/O и 
	использовании буферов и каналов вместо потоков (streams). Это делает Java NIO особенно полезным для высокопроизводительных приложений, таких как сетевые серверы.
	Главные составляющие Java NIO:
		Буферы (Buffers) — это контейнеры для данных, которые используются для чтения и записи информации в каналы. 
			Они представляют собой фиксированные блоки памяти, с которыми работают каналы.

		Каналы (Channels)— это абстракции для работы с источниками и приемниками данных (например, файлами, сокетами). 
		Они поддерживают как блокирующий, так и неблокирующий режимы работы.

		Селекторы (Selectors) позволяют одному потоку управлять несколькими каналами. Это особенно полезно для создания неблокирующих сетевых приложений, 
			где один поток может обрабатывать множество соединений.

40. Что такое канал?
	Каналы — это абстракции для работы с источниками и приемниками данных (например, файлами, сокетами). 
	Они поддерживают как блокирующий, так и неблокирующий режимы работы.
	Основные типы каналов:
		FileChannel: Для работы с файлами.
		SocketChannel: Для работы с TCP-сокетами.
		ServerSocketChannel: Для принятия TCP-соединений.
		DatagramChannel: Для работы с UDP-сокетами.
	Основные методы каналов:
		read(): Чтение данных из канала в буфер.
		write(): Запись данных из буфера в канал.
		configureBlocking(): Установка блокирующего или неблокирующего режима.

41. Что такое буфер?
	Буферы — это контейнеры для данных, которые используются для чтения и записи информации в каналы. 
	Они представляют собой фиксированные блоки памяти, с которыми работают каналы.
		Основные типы буферов:
			ByteBuffer
			CharBuffer
			IntBuffer
			LongBuffer
			FloatBuffer
			DoubleBuffer
		Основные методы буферов:
			put(): Запись данных в буфер.
			get(): Чтение данных из буфера.
			flip(): Переключение буфера из режима записи в режим чтения.
			clear(): Очистка буфера для повторного использования.
			rewind(): Перемотка буфера для повторного чтения.

42. Что такое селектор?
	Селекторы позволяют одному потоку управлять несколькими каналами. Это особенно полезно для 
	создания неблокирующих сетевых приложений, где один поток может обрабатывать множество соединений.
	Основные методы селекторов:
		open(): Создание селектора.
		register(): Регистрация канала в селекторе.
		select(): Ожидание событий на зарегистрированных каналах.
		selectedKeys(): Получение набора ключей (событий) для обработки.

43. Когда есть смысл использовать Java NIO?
	Java NIO предоставляет мощные инструменты для работы с вводом-выводом, особенно для высокопроизводительных приложений.
	Его основные компоненты — буферы, каналы и селекторы — позволяют эффективно управлять данными и множеством соединений. 
	Однако использование Java NIO требует глубокого понимания его работы и осторожности при реализации.
	Недостатки Java NIO:
	Сложность:
		API Java NIO сложнее, чем классический Java IO.
	Ошибки:
		Неправильное использование буферов и каналов может привести к ошибкам, таким как утечки памяти или блокировки.
	Ограниченная поддержка:
		Не все операции поддерживаются в неблокирующем режиме.

44. Что такое PipedStreams? Как они устроены?
	PipedStreams в Java — это механизм для организации однонаправленной передачи данных между потоками (threads) через канал (pipe). 
	Они используются для передачи данных от одного потока (производителя) к другому (потребителю) без использования промежуточных структур данных, 
	таких как очереди или коллекции.
	Основные классы PipedStreams:
		PipedInputStream: Класс, который представляет входной поток данных. Он используется для чтения данных из канала.
		PipedOutputStream:Класс, который представляет выходной поток данных. Он используется для записи данных в канал.
	Эти два потока должны быть соединены между собой, чтобы данные могли передаваться от PipedOutputStream к PipedInputStream.
	Как устроены PipedStreams?
	Соединение потоков:
		Потоки PipedInputStream и PipedOutputStream должны быть соединены. Это можно сделать двумя способами:
		Через конструктор:
			PipedInputStream input = new PipedInputStream();
			PipedOutputStream output = new PipedOutputStream(input);

		Через метод connect():
			PipedInputStream input = new PipedInputStream();
			PipedOutputStream output = new PipedOutputStream();
			input.connect(output); // или output.connect(input);
		
		Передача данных:
			Данные записываются в PipedOutputStream одним потоком (производителем).
			Данные читаются из PipedInputStream другим потоком (потребителем).
		Буферизация:
			Внутри PipedInputStream и PipedOutputStream используется буфер для хранения данных. 
			Размер буфера по умолчанию составляет 1024 байта, но его можно изменить через конструктор.
		Блокировка:
			Если буфер PipedInputStream пуст, поток-потребитель блокируется до тех пор, пока данные не появятся.
			Если буфер PipedOutputStream заполнен, поток-производитель блокируется до тех пор, пока потребитель не освободит место.
